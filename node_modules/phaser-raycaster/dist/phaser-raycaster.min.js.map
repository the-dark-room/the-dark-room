{"version":3,"file":"phaser-raycaster.min.js","mappings":"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","sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/destroy.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/debug.js","webpack://PhaserRaycaster/./src/ray/destroy.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/stats.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/webpack/runtime/define property getters","webpack://PhaserRaycaster/webpack/runtime/hasOwnProperty shorthand","webpack://PhaserRaycaster/webpack/runtime/make namespace object","webpack://PhaserRaycaster/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(self, function() {\nreturn ","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2022 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * Point object\r\n * @typedef {Object} Point\r\n * @property {number} x\r\n * @property {number} y\r\n */\r\n \r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster plugin class.\r\n * \r\n * @namespace PhaserRaycaster\r\n * @class PhaserRaycaster\r\n * @extends Phaser.Plugins.ScenePlugin\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {Phaser.Scene} scene\r\n * @param {Phaser.Plugins.PluginManager} pluginManager\r\n */\r\n\r\nclass PhaserRaycaster extends Phaser.Plugins.ScenePlugin {\r\n    constructor(scene, pluginManager) {\r\n        super(scene, pluginManager);\r\n\r\n        this._Raycaster = require('./raycaster-core.js').Raycaster;\r\n    }\r\n\r\n    /**\r\n    * Create Raycaster object.\r\n    *\r\n    * @method PhaserRaycaster#createRaycaster\r\n    * @memberof PhaserRaycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n    * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    createRaycaster(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n}\r\n\r\n//Make sure you export the plugin for webpack to expose\r\nmodule.exports = PhaserRaycaster;","/**\r\n* Get mapped object's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    return this.object.getBounds();\r\n}\r\n","let rectangle = require('./map-rectangle-methods.js');\r\nlet line = require('./map-line-methods.js');\r\nlet polygon = require('./map-polygon-methods.js');\r\nlet arc = require('./map-circle-methods.js');\r\nlet container = require('./map-container-methods.js');\r\nlet tilemap = require('./map-tilemap-methods.js');\r\nlet matterBody = require('./map-matterBody-methods.js');\r\nlet segmentCount = require('./segmentsCount.js');\r\nlet boundingBox = require('./boundingBox.js');\r\n\r\n/**\r\n * Configure map.\r\n *\r\n * @method Raycaster.Map#config\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Map's congfiguration options. May include:\r\n * @param {object} options.object - Game object to map\r\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\r\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\r\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\r\n * @param {number} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped.\r\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\r\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\r\n * \r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //object type\r\n    if(options.type === undefined)\r\n        options.type = options.object.type;\r\n    if(options.type === 'body' || options.type === 'composite')\r\n        options.type = 'MatterBody';\r\n    this.type = options.type;\r\n    \r\n    switch(options.type) {\r\n        case 'Polygon':\r\n            this.getPoints = polygon.getPoints;\r\n            this.getSegments = polygon.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = polygon.updateMap;\r\n            break;\r\n        case 'Arc':\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            this.circle = (options.segmentCount) ? false : true;\r\n            this.getPoints = arc.getPoints;\r\n            this.getSegments = arc.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = arc.updateMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'Line':\r\n            this.getPoints = line.getPoints;\r\n            this.getSegments = line.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = line.updateMap;\r\n            break;\r\n        case 'Container':\r\n            //container's child\r\n            this.mapChild = (options.mapChild) ? options.mapChild : null;\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            //transformed container's circle children\r\n            this._circles = [];\r\n            this.getPoints = container.getPoints;\r\n            this.getSegments = container.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = container.updateMap;\r\n            this._updateChildMap = container._updateChildMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'StaticTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'DynamicTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'TilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'MatterBody':\r\n            //force convex body (hull) mapping\r\n            this.forceConvex = (options.forceConvex) ? true : false;\r\n            //force mapping by vertices\r\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\r\n            this.circle = false;\r\n            this.getPoints = matterBody.getPoints;\r\n            this.getSegments = matterBody.getSegments;\r\n            this.getBoundingBox = matterBody.getBoundingBox;\r\n            this.updateMap = matterBody.updateMap;\r\n            break;\r\n        default:\r\n            this.getPoints = rectangle.getPoints;\r\n            this.getSegments = rectangle.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = rectangle.updateMap;\r\n    }\r\n\r\n    //if object is not supported\r\n    if(this.type != 'MatterBody' && typeof this.object.getBounds !== 'function') {\r\n        this.notSupported = true;\r\n    }\r\n\r\n    //dynamic map\r\n    this.dynamic = (options.dynamic == true) ? true : false;\r\n\r\n    //enable/disable map\r\n    this.active = (options.active !== undefined) ? options.active : true;\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Map#destroy\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    //destroy reference to map object in mapped object\r\n    if(this.object.type === 'body' || this.object.type === 'composite') {\r\n        delete object.raycasterMap;\r\n    }\r\n    else if(this.object.data) {\r\n        this.object.data.remove('raycasterMap');\r\n    }\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/*Map methods for circles*/\r\n/**\r\n* Get array of mapped circle's vertices used as rays targets.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\r\n*\r\n* @method Raycaster.Map#arc.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped circle's segments used to test object's intersection with ray.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\r\n*\r\n* @method Raycaster.Map#arc.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update circles's map of points and segments.\r\n*\r\n* @method Raycaster.Map#arc.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for containers*/\r\n/**\r\n* Get array of mapped container's and its children vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#container.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n* @param {boolean} [isChild] - Flag definig if it is child container.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false, isChild = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let points = this._points;\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    //get tangent points of container's circles\r\n    if(this.segmentCount == 0 && !isChild) {\r\n        if(ray) {\r\n            //create temporary ray\r\n            let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\r\n    \r\n            let tempRay = ray._raycaster.createRay({\r\n                origin: {\r\n                    x: vector.getPointB().x,\r\n                    y: vector.getPointB().y\r\n                }\r\n            });\r\n\r\n            //calculate tangent rays\r\n            let rayA = new Phaser.Geom.Line();\r\n            let rayB = new Phaser.Geom.Line();\r\n            let c;\r\n\r\n            for(let circle of this._circles) {\r\n                circle.points = [];\r\n                c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, circle.x, circle.y);\r\n\r\n                let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(circle.radius, 2));\r\n\r\n                //ray angle\r\n                let angle = Phaser.Geom.Line.Angle(c);\r\n                let dAngle = Math.asin((circle.radius) / Phaser.Geom.Line.Length(c));\r\n                Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n                Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n                //adding tangent points\r\n                circle.points.push(rayA.getPointB());\r\n                circle.points.push(rayB.getPointB());\r\n                points.push(rayA.getPointB());\r\n                points.push(rayB.getPointB());\r\n            }\r\n        }\r\n    }\r\n    \r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#container.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update container's and its children maps of points and segments.\r\n*\r\n* @method Raycaster.Map#container.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let container = this.object;\r\n    this._circles = [];\r\n\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    let rotation = container.rotation;\r\n\r\n    if(this.mapChild) {\r\n        this._updateChildMap(this.mapChild, points, segments, rotation, offset);\r\n    }\r\n    else {\r\n        //iterate through container's children\r\n        container.iterate(function(child){\r\n            this._updateChildMap(child, points, segments, rotation, offset);\r\n        }.bind(this));\r\n\r\n        //get children intersections\r\n        for(let i = 0, iLength = container.list.length; i < iLength; i++){\r\n            let childA = container.list[i];\r\n            let mapA = childA.data.get('raycasterMap');\r\n            \r\n            if(!mapA)\r\n                continue;\r\n\r\n            for(let j = i+1, jLength = container.list.length; j < jLength; j++){\r\n                let childB = container.list[j];\r\n                let mapB = childB.data.get('raycasterMap');\r\n                //check if bounding boxes overlap\r\n                if(!mapB || !Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\r\n                    continue;\r\n\r\n                //find objects intersections\r\n                for(let segmentA of mapA.getSegments()) {\r\n                    for(let segmentB of mapB.getSegments()) {\r\n                        let intersection = [];\r\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                            continue;\r\n                        \r\n                        //calculate positions after container's rotation\r\n                        if(rotation !== 0) {\r\n                            let vector = new Phaser.Geom.Line(container.x, container.y, intersection.x * container.scaleX + offset.x, intersection.y * container.scaleY + offset.y);\r\n                            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                            points.push(vector.getPointB());\r\n                        }\r\n                        //if rotation === 0\r\n                        else\r\n                            points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n* Update container's child map of points and segments.\r\n*\r\n* @method Raycaster.Map#container._updateChildMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.10.3\r\n*\r\n* @param {object} [child] - Container's child object.\r\n* @param {Phaser.Geom.Point[]} [points] - Container's mapped points.\r\n* @param {Phaser.Geom.Line[]} [segments] - Container's mapped segments.\r\n* @param {number} [rotation] - Container's rotation.\r\n* @param {Phaser.Geom.Point} [offset] - Container's offset.\r\n*/\r\nexport function _updateChildMap(child, points, segments, rotation, offset) {\r\n    if(!child.data)\r\n        child.setDataEnabled();\r\n\r\n    //if object is not supported\r\n    if(child.data.get('raycasterMapNotSupported'))\r\n        return;\r\n\r\n    //get child map\r\n    let map = child.data.get('raycasterMap');\r\n    if(!map) {\r\n        map = new this.constructor({\r\n            object: child,\r\n            segmentCount: this.segmentCount\r\n        });\r\n\r\n        if(map.notSupported) {\r\n            map.destroy();\r\n            child.data.set('raycasterMapNotSupported', true);\r\n            return;\r\n        }\r\n\r\n        child.data.set('raycasterMap', map);\r\n    }\r\n    else\r\n        map.updateMap();\r\n\r\n    //add child points\r\n    let childPoints = [];\r\n    for(let point of map.getPoints(false, true)) {\r\n        //calculate positions after container's rotation\r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n        //if rotation === 0\r\n        else\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\r\n\r\n        childPoints.push(points[points.length - 1])\r\n    }\r\n\r\n    //add child segments\r\n    for(let segment of map.getSegments()) {\r\n        //calculate positions after container's rotation\r\n        if(rotation !== 0) {\r\n            let pointA = segment.getPointA();\r\n            let pointB = segment.getPointB();\r\n            let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n            let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n            Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n\r\n            segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\r\n        }\r\n        //if rotation === 0\r\n        else\r\n            segments.push(new Phaser.Geom.Line(segment.getPointA().x * this.object.scaleX + offset.x, segment.getPointA().y * this.object.scaleY + offset.y, segment.getPointB().x * this.object.scaleX + offset.x, segment.getPointB().y * this.object.scaleY + offset.y));\r\n    }\r\n\r\n    //if child's map is a circle and this.segmentsCount == 0, store transformed circles in this._circles array.\r\n    if(map.type == 'Arc' && this.segmentCount == 0) {\r\n        let circleOffset = new Phaser.Geom.Point();\r\n        circleOffset.x = (map.object.x - map.object.displayWidth * (map.object.originX - 0.5)) * this.object.scaleX + offset.x;\r\n        circleOffset.y = (map.object.y - map.object.displayHeight * (map.object.originY - 0.5))  * this.object.scaleY + offset.y;\r\n\r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            circleOffset = vector.getPointB();\r\n        }\r\n\r\n        this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, map.object.radius * map.object.scaleX * this.object.scaleX));\r\n    }\r\n    else if(map.type === 'Container') {\r\n        for(let childMapCircle of map._circles) {\r\n            let circleOffset = new Phaser.Geom.Point();\r\n                circleOffset.x = childMapCircle.x * this.object.scaleX + offset.x;\r\n                circleOffset.y = childMapCircle.y * this.object.scaleY + offset.y;\r\n\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\r\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                circleOffset = vector.getPointB();\r\n            }\r\n\r\n            this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, childMapCircle.radius * this.object.scaleX));\r\n        }\r\n    }\r\n}\r\n","/**\r\n * @classdesc\r\n *\r\n * Map class responsible for mapping game objects.\r\n *\r\n * @namespace Raycaster.Map\r\n * @class Raycaster.Map\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Map specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Map(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Map#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.9.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Mapped object's type\r\n    *\r\n    * @name Raycaster.Map#type\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.type;\r\n    /**\r\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\r\n    *\r\n    * @name Raycaster.Map#active\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.7.2\r\n    */\r\n    this.active;\r\n    /**\r\n    * If set true, map will be automatically updated on scene update event.\r\n    *\r\n    * @name Raycaster.Map#dynamic\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.6.0\r\n    */\r\n    this.dynamic;\r\n    /**\r\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\r\n    *\r\n    * @name Raycaster.Map#circle\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.9.0\r\n    */\r\n    this.circle = false;\r\n    /**\r\n    * Reference to mapped object.\r\n    *\r\n    * @name Raycaster.Map#object\r\n    * @type {object}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.object;\r\n    /**\r\n    * Array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @name Raycaster.Map#_points\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._points = [];\r\n    /**\r\n    * Array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @name Raycaster.Map#_segments\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._segments = [];\r\n    /**\r\n    * Get array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @method Raycaster.Map#getPoints\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\r\n    */\r\n    this.getPoints;\r\n    /**\r\n    * Get array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @method Raycaster.Map#getSegments\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\r\n    */\r\n    this.getSegments;\r\n    /**\r\n    * Get mapped object's bounding box.\r\n    *\r\n    * @method Raycaster.Map#getBoundingBox\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.9.0\r\n    *\r\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\r\n    */\r\n    this.getBoundingBox;\r\n    /**\r\n    * Update object's map of points and segments.\r\n    *\r\n    * @method Raycaster.Map#updateMap\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n    */\r\n    this.updateMap;\r\n\r\n    this.config(options);\r\n    if(!this.notSupported)\r\n        this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\nMap.prototype = {\r\n    config: require('./config.js').config,\r\n    destroy: require('./destroy.js').destroy\r\n};\r\n\r\nMap.prototype.constructor = Map;\r\n","/*Map methods for lines*/\r\n/**\r\n* Get array of mapped line's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#line.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped line's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#line.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update line's map of points and segments.\r\n*\r\n* @method Raycaster.Map#line.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\r\n    }\r\n    \r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for matter body*/\r\n/**\r\n* Get array of mapped matter body's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#matterBody.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n\r\n    //calculate tangent rays\r\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\r\n        let points = [];\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n\r\n        return points;\r\n    }\r\n\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped matter body's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#matterBody.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update matter body's map of points and segments.\r\n*\r\n* @method Raycaster.Map#matterBody.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n    let bodies = [body];\r\n    let generateBounds = false;\r\n\r\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\r\n        this.circle = true;\r\n        this._points = points;\r\n        this._segments = segments;\r\n\r\n        return this;\r\n    }\r\n\r\n    this.circle = false;\r\n\r\n    if(body.type == 'composite')\r\n        bodies = body.bodies;\r\n\r\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\r\n        generateBounds = true;\r\n    }\r\n    \r\n    for(let bodyItem of bodies) {\r\n        //if convex body\r\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\r\n            let vertices = bodyItem.parts[0].vertices;\r\n\r\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\r\n\r\n            for(let i = 1, length = vertices.length; i < length; i++) {\r\n                let pointA = new Phaser.Geom.Point(vertices[i - 1].x, vertices[i - 1].y);\r\n                let pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\r\n\r\n                points.push(pointB);\r\n\r\n                //add segment\r\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n                segments.push(segment);\r\n            }\r\n\r\n            //closing segment\r\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\r\n            segments.push(segment);\r\n        }\r\n\r\n        //if concave body\r\n        else if(bodyItem.parts.length > 1) {\r\n            for(let i = 1, length = bodyItem.parts.length; i < length; i++) {\r\n                let vertices = bodyItem.parts[i].vertices;\r\n                let pointA = new Phaser.Geom.Point(vertices[0].x, vertices[0].y);\r\n\r\n                if(points.find(point => point.x == pointA.x && point.y == pointA.y) === undefined)\r\n                    points.push(pointA);\r\n\r\n                for(let j = 1, length = vertices.length; j < length; j++) {\r\n                    let pointB = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\r\n                    //check if segment was already added\r\n                    let segmentIndex = segments.findIndex(segment => (segment.x1 == pointA.x && segment.y1 == pointA.y && segment.x2 == pointB.x && segment.y2 == pointB.y) || (segment.x1 == pointB.x && segment.y1 == pointB.y && segment.x2 == pointA.x && segment.y2 == pointA.y));\r\n                    \r\n                    if(segmentIndex !== -1) {\r\n                        segments.splice(segmentIndex, 1);\r\n                        pointA = pointB;\r\n                        continue;\r\n                    }\r\n                    \r\n                    if(points.find(point => point.x == pointB.x && point.y == pointB.y) === undefined)\r\n                        points.push(pointB);\r\n\r\n                    //add segment\r\n                    let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n                    segments.push(segment);\r\n                    \r\n                    pointA = pointB;\r\n                }\r\n                \r\n                //closing segment\r\n                let closingSegment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\r\n\r\n                let segmentIndex = segments.findIndex(segment => (segment.x1 == closingSegment.x1 && segment.y1 == closingSegment.y1 && segment.x2 == closingSegment.x2 && segment.y2 == closingSegment.y2) || (segment.x1 == closingSegment.x2 && segment.y1 == closingSegment.y2 && segment.x2 == closingSegment.x1 && segment.y2 == closingSegment.y1));\r\n                if(segmentIndex === undefined)\r\n                    segments.push(closingSegment);\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    if(generateBounds) {\r\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\r\n        body.bounds = bounds;\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n* Get matter body's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\r\n\r\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\r\n}\r\n\r\n","/*Map methods for polygons*/\r\n/**\r\n* Get array of mapped polygon's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#polygon.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped polygon's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#polygon.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update polygon's map of points and segments.\r\n*\r\n* @method Raycaster.Map#polygon.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is closed\r\n    if(this.object.closePath) {\r\n        let last = points.length - 1;\r\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for rectangles*/\r\n/**\r\n* Get array of mapped rectangle's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#rectangle.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#rectangle.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update rectangle's map of points and segments.\r\n*\r\n* @method Raycaster.Map#rectangle.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n        \r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for tilemaps*/\r\n/**\r\n* Get array of mapped tilemap's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#tilemap.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\r\n        return this._points;\r\n\r\n    let points = [];\r\n    for(let point of this._points) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\r\n            points.push(point);\r\n    }\r\n\r\n    //get intersections between tilemap's segments and ray's detection range edge\r\n    let segments = this.getSegments(ray);\r\n\r\n    for(let segment of segments) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\r\n        \r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#tilemap.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\r\n        return this._segments;\r\n\r\n    let segments = [];\r\n    for(let segment of this._segments) {\r\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\r\n            segments.push(segment);\r\n        }\r\n    }\r\n\r\n    return segments;\r\n};\r\n\r\n/**\r\n* Update tilemap's map of points and segments.\r\n*\r\n* @method Raycaster.Map#tilemap.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x;\r\n    offset.y = this.object.y;\r\n\r\n    let horizontal = false;\r\n    let horizontals = [];\r\n    let verticals = [];\r\n\r\n    //iterate rows\r\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\r\n        let row = this.object.layer.data[i];\r\n\r\n        //iterate row's tiles\r\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\r\n            let tile = row[j];\r\n\r\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\r\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\r\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\r\n\r\n            //get current tile's column last vertical line\r\n            let vertical = false;\r\n            if(verticals.length <= j)\r\n                verticals[j] = [];\r\n            else if(verticals[j].length > 0)\r\n                vertical = verticals[j][verticals[j].length - 1];\r\n\r\n            //check if tile has edge from left\r\n            if(leftEdge) {\r\n                if(vertical && vertical.y + vertical.height == i)\r\n                    vertical.height++;\r\n                else {\r\n                    verticals[j].push({\r\n                        x: tile.x,\r\n                        y: tile.y,\r\n                        height: 1\r\n                    });\r\n                }\r\n            }\r\n\r\n            //check if tile has edge from top\r\n            if(upperEdge) {\r\n                if(horizontal)\r\n                    horizontal.width++;\r\n                else\r\n                    horizontal = {\r\n                        x: tile.x,\r\n                        y: tile.y,\r\n                        width: 1\r\n                    };\r\n                continue;\r\n            }\r\n\r\n            if(horizontal) {\r\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n                segments.push(segment);\r\n                horizontals.push(segment);\r\n                points.push(new Phaser.Geom.Point(x, y));\r\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n                horizontal = false;\r\n            }\r\n        }\r\n        \r\n        //at the end of row add segment if exist\r\n        if(horizontal) {\r\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n            segments.push(segment);\r\n            horizontals.push(segment);\r\n            points.push(new Phaser.Geom.Point(x, y));\r\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n            horizontal = false;\r\n        }\r\n    }\r\n\r\n    //add bottom horizontal segments\r\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\r\n        if(this.collisionTiles.includes(tile.index)) {\r\n            if(horizontal)\r\n                horizontal.width++;\r\n            else\r\n                horizontal = {\r\n                    x: tile.x,\r\n                    y: tile.y + 1,\r\n                    width: 1\r\n                };\r\n            continue;\r\n        }\r\n\r\n        if(horizontal) {\r\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n            segments.push(segment);\r\n            horizontals.push(segment);\r\n            points.push(new Phaser.Geom.Point(x, y));\r\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n            horizontal = false;\r\n        }\r\n    }\r\n\r\n    //add segment if exist\r\n    if(horizontal) {\r\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n        segments.push(segment);\r\n        horizontals.push(segment);\r\n        points.push(new Phaser.Geom.Point(x, y));\r\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n        horizontal = false;\r\n    }\r\n    \r\n    //add right vertical segments\r\n    let vertical = false;\r\n    let verticalsLastColumn = [];\r\n    for(let row of this.object.layer.data) {\r\n        let tile = row[row.length - 1];\r\n\r\n        //if tile blocks ray\r\n        if(this.collisionTiles.includes(tile.index)) {\r\n            if(vertical) {\r\n                vertical.height++;\r\n            }\r\n            else {\r\n                vertical = {\r\n                    x: tile.x + 1,\r\n                    y: tile.y,\r\n                    height: 1\r\n                };\r\n            }\r\n\r\n            continue;\r\n        }\r\n\r\n        if(vertical) {\r\n            verticalsLastColumn.push(vertical);\r\n            vertical = false;\r\n        }\r\n    }\r\n\r\n    verticals.push(verticalsLastColumn);\r\n    \r\n    //add vertical segments\r\n    for(let column of verticals) {\r\n        if(!column)\r\n            continue;\r\n\r\n        for(let vertical of column) {\r\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\r\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\r\n            segments.push(segment);\r\n\r\n            //add points if they're not already there\r\n            if(!points.filter(point => point.x == x && point.y == y1))\r\n                points.push(new Phaser.Geom.Point(x, y));\r\n\r\n            if(!points.filter(point => point.x == x && point.y == y2))\r\n                points.push(new Phaser.Geom.Point(x, y));\r\n\r\n            //get intersections between horizontal segments and vertical\r\n            for(let horizontalSegment of horizontals) {\r\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\r\n                    continue;\r\n\r\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\r\n                    continue;\r\n\r\n                let point = new Phaser.Geom.Point();\r\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\r\n                    points.push(point);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n\r\n/**\r\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\r\n*\r\n* @method Raycaster.Map#setCollisionTiles\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @since 0.7.3\r\n*\r\n* @param {array} [tiles = []] - Set of tile's indexes to map.\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function setCollisionTiles(tiles = []) {\r\n    this.collisionTiles = tiles;\r\n    return this;\r\n}\r\n","/**\r\n * Set segment count for cirle's map.\r\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n *\r\n * @method Raycaster.Map#setSegmentCount\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} count - Circle map's segment count.\r\n *\r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function setSegmentCount(count) {\r\n    this.segmentCount = count;\r\n    this.circle = count ? false : true;\r\n\r\n    this.updateMap();\r\n    return this;\r\n}\r\n","/**\r\n * Set ray's angle (direction) in radians.\r\n *\r\n * @method Raycaster.Ray#setAngle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [angle = 0] - Ray's angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngle(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's angle (direction) in degrees.\r\n *\r\n * @method Raycaster.Ray#setAngleDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.1\r\n *\r\n * @param {number} [angle = 0] - Ray's angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngleDeg(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n","/**\r\n * Cast ray to find closest intersection with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#cast\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\r\n * @param {Phaser.Geom.Point|Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\r\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\r\n *\r\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\r\n */\r\nexport function cast(options = {}) {\r\n    let closestIntersection;\r\n    let closestSegment;\r\n    let closestObject;\r\n    let closestDistance = this.rayRange;\r\n    let internal = options.internal ? options.internal : false;\r\n    let startTime = performance.now();\r\n    let stats = {\r\n        method: 'cast',\r\n        rays: 1,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //if bounding box is defined check bounding box intersection\r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        let intersections = [];\r\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\r\n        if(intersections.length === 1)\r\n            closestIntersection = intersections[0];\r\n        else if(intersections.length > 1) {\r\n            for(let intersection of intersections) {\r\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                if(distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestIntersection = intersection;\r\n                }\r\n            }\r\n        }\r\n        //if ray target is declared\r\n        else if(options.target){\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\r\n            //if target is within ray range\r\n            if(this.rayRange > distance) {\r\n                closestDistance = distance;\r\n                closestIntersection = options.target;\r\n            }\r\n        }\r\n    }\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n    \r\n    for(let object of options.objects) {\r\n        let map, boundingBox;\r\n        \r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        stats.testedMappedObjects++;\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        if(internal) {\r\n            boundingBox = map._boundingBox;\r\n        }\r\n        else {\r\n            boundingBox = map.getBoundingBox();\r\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n        }\r\n\r\n        //check if object is intersected by ray\r\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox).length === 0)\r\n            continue;\r\n\r\n        stats.hitMappedObjects++;\r\n        stats.segments += map.getSegments(this).length;\r\n        \r\n        //check intersections\r\n        for(let segment of map.getSegments(this)) {\r\n            let intersection = [];\r\n\r\n            //if target point is segmemt point\r\n            if(options.target) {\r\n                if(\r\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\r\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\r\n                ) {\r\n                    intersection = options.target;\r\n                }\r\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                    continue;\r\n            }\r\n            //if no intersection continue\r\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n              continue;\r\n            \r\n            //get closest intersection\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n            if(distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestIntersection = intersection;\r\n                closestObject = map.object;\r\n                closestSegment = segment;\r\n            }\r\n        }\r\n\r\n        //check if map is circular\r\n        if(map.circle) {\r\n           //if circular map has generated points (besides tangent points to ray)\r\n            if(map._points.length > 0) {\r\n                continue;\r\n            }\r\n            \r\n            //check if target point is a circle tangent point to ray\r\n            if(options.target) {\r\n                let points = map.getPoints(this);\r\n                let isTangent = false;\r\n                for(let point of points) {\r\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = point;\r\n                            closestObject = map.object;\r\n                            isTangent = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(isTangent)\r\n                    continue;\r\n            }\r\n\r\n            let circleIntersections = [];\r\n            let offset = new Phaser.Geom.Point();\r\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\r\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\r\n\r\n            //calculate circle's center after rotation\r\n            let rotation = map.object.rotation;\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\r\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                let cB = vector.getPointB();\r\n                offset.x = cB.x;\r\n                offset.y = cB.y;\r\n            }\r\n\r\n            //create transformed circle\r\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\r\n\r\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                for(let intersection of circleIntersections) {\r\n                    //get closest intersection\r\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                    if(distance < closestDistance) {\r\n\r\n                        closestDistance = distance;\r\n                        closestIntersection = intersection;\r\n                        closestObject = map.object;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //check container map's circles\r\n        if(map.type == 'Container' && map._circles.length > 0) {\r\n            for(let circle of map._circles) {\r\n                //check if target point is a circle tangent point to ray\r\n                if(options.target) {\r\n                    let isTangent = false;\r\n\r\n                    for(let point of circle.points) {\r\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                            //get closest intersection\r\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                            if(distance < closestDistance) {\r\n                                closestDistance = distance;\r\n                                closestIntersection = point;\r\n                                closestObject = map.object;\r\n                                isTangent = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(isTangent)\r\n                        continue;\r\n                }\r\n\r\n                let circleIntersections = [];\r\n\r\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                    for(let intersection of circleIntersections) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = intersection;\r\n                            closestObject = map.object;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //update stats\r\n    if(internal) {\r\n        this._stats.rays++;\r\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\r\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\r\n        this._stats.segments += stats.segments;\r\n    }\r\n    else {\r\n        stats.time = performance.now() - startTime;\r\n        this._stats = stats;\r\n    }\r\n\r\n    let result;\r\n    if(!closestIntersection) {\r\n        if(this.ignoreNotIntersectedRays)\r\n            return false;\r\n\r\n        result = this._ray.getPointB();\r\n    }\r\n    else {\r\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\r\n        result.segment = closestSegment;\r\n        result.object = closestObject;\r\n    }\r\n\r\n    if(this.round) {\r\n        result.x = Math.round(result.x);\r\n        result.y = Math.round(result.y);\r\n    }\r\n\r\n    if(!internal)\r\n        this.drawDebug([result]);\r\n    \r\n    return result;\r\n}","/**\r\n * Cast ray in all directions to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCircle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\r\n */\r\nexport function castCircle(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let startTime = performance.now();\r\n    //reset stats\r\n    this._stats = {\r\n        method: 'castCircle',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n\r\n    //if bounding box is defined add bounding box points to \r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        for(let point of this._raycaster.boundingBox.points) {\r\n            rayTargets.push({\r\n                point: point,\r\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n            });\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map, boundingBox;\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        boundingBox = map.getBoundingBox();\r\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n\r\n        map._boundingBox = boundingBox;\r\n\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n            rayTargets.push({\r\n                point: point,\r\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n            });\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB;\r\n            if(objectB.type === 'body' || objectB.type === 'composite')\r\n                mapB = objectB.raycasterMap;\r\n            else {\r\n                mapB = objectB.data.get('raycasterMap');\r\n            }\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    \r\n                    rayTargets.push({\r\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angle - b.angle;\r\n    }.bind(this));\r\n\r\n    let previousTarget = {\r\n        angle: false\r\n    };\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        //if current target is the same as previous one skip loop\r\n        if(target.angle === previousTarget.angle) {\r\n            continue;\r\n        }\r\n\r\n        previousTarget = target;\r\n\r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point,\r\n            internal: true\r\n        });\r\n\r\n        if(intersection){\r\n            //if intersection hits target point cast two additional rays\r\n            let castSides = false;\r\n            if(this.round) {\r\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n            }\r\n            else {\r\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n            }\r\n            \r\n            if(castSides) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionA) {\r\n                    intersections.push(intersectionA);\r\n                }\r\n\r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionB) {\r\n                    intersections.push(intersectionB);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice();\r\n\r\n    this._stats.time = performance.now() - startTime;\r\n\r\n    this.drawDebug(intersections);\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Cast ray in a cone to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\r\n */\r\nexport function castCone(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let cone = this.cone;\r\n    let minAngle = 0;\r\n    let maxAngle = 0;\r\n    let angleOffset = 0;\r\n    let startTime = performance.now();\r\n    //reset stats\r\n    this._stats = {\r\n        method: 'castCone',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //set cone\r\n    if(options.cone !== undefined)\r\n        cone = options.cone;\r\n    if(options.coneDeg !== undefined)\r\n        cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //set cone min and max angle\r\n    minAngle = this.angle - cone / 2;\r\n    maxAngle = this.angle + cone / 2;\r\n\r\n    //add min and max angle points\r\n    this.setAngle(minAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: minAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\r\n    });\r\n\r\n    this.setAngle(maxAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: maxAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\r\n    });\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n\r\n    //if bounding box is defined add bounding box points to \r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        for(let point of this._raycaster.boundingBox.points) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: angle,\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map, boundingBox;\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        boundingBox = map.getBoundingBox();\r\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n\r\n        map._boundingBox = boundingBox;\r\n\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB;\r\n            if(objectB.type === 'body' || objectB.type === 'composite')\r\n                mapB = objectB.raycasterMap;\r\n            else\r\n                mapB = objectB.data.get('raycasterMap');\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                        rayTargets.push({\r\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\r\n                            angleOffsetDeg: -angleOffsetDeg\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angleOffsetDeg - b.angleOffsetDeg;\r\n    }.bind(this));\r\n\r\n    let previousTarget = {\r\n        angle: false\r\n    };\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        //if current target is the same as previous one skip loop\r\n        if(target.angle === previousTarget.angle) {\r\n            continue;\r\n        }\r\n\r\n        previousTarget = target;\r\n        \r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point,\r\n            internal: true\r\n        });\r\n        if(intersection){\r\n            //if intersection hits target point cast two additional rays\r\n            let castSides = false;\r\n            if(this.round) {\r\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n            }\r\n            else {\r\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n            }\r\n            if(castSides) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionA) {\r\n                    intersections.push(intersectionA);\r\n                }\r\n\r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionB) {\r\n                    intersections.push(intersectionB);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice(intersections, false);\r\n    \r\n    this._stats.time = performance.now() - startTime;\r\n\r\n    this.drawDebug(intersections);\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Set ray's cone angle (width) in radians.\r\n *\r\n * @method Raycaster.Ray#setCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {number} [cone = 0] - Ray's cone angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCone(cone = 0) {\r\n    this.cone = cone;\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's cone angle (width) in degrees.\r\n *\r\n * @method Raycaster.Ray#setConeDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {number} [cone = 0] - Ray's cone angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setConeDeg(cone = 0) {\r\n    this.cone = Phaser.Math.DegToRad(cone);\r\n    return this;\r\n}\r\n","/**\r\n * Configure ray.\r\n *\r\n * @method Raycaster.Ray#config\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //origin\r\n    if(options.origin !== undefined)\r\n        this.origin.setTo(options.origin.x, options.origin.y);\r\n\r\n    //angle\r\n    if(options.angle !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\r\n\r\n    //angle deg\r\n    if(options.angleDeg !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\r\n\r\n    //cone angle\r\n    if(options.cone !== undefined)\r\n        this.cone = options.cone;\r\n\r\n    //cone angle deg\r\n    if(options.coneDeg !== undefined)\r\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //ray range (0 = max)\r\n    if(options.rayRange !== undefined)\r\n        this.rayRange = options.rayRange;\r\n\r\n    //collision range (0 = max)\r\n    if(options.collisionRange !== undefined)\r\n        this.collisionRange = options.collisionRange;\r\n\r\n    //detection range (0 = max)\r\n    if(options.detectionRange !== undefined)\r\n        this.detectionRange = options.detectionRange;\r\n\r\n    //ignore not intersected rays\r\n    if(options.ignoreNotIntersectedRays !== undefined)\r\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\r\n    \r\n    //round\r\n    if(options.round !== undefined)\r\n        this.round = (options.round == true)\r\n\r\n    //auto slice\r\n    if(options.autoSlice !== undefined)\r\n        this.autoSlice = (options.autoSlice == true)\r\n\r\n    //enable physics\r\n    if(options.enablePhysics !== undefined && options.enablePhysics)\r\n        this.enablePhysics(options.enablePhysics);\r\n    \r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\r\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        this.graphics.setDepth(1000);\r\n    }\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Ray#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/**\r\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\r\n *\r\n * @method Raycaster.Ray#enablePhysics\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function enablePhysics(type = 'arcade') {\r\n    \r\n    if(this.body !== undefined)\r\n        return this;\r\n\r\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\r\n    this.collisionCircle._ray = this;\r\n\r\n    if(type === 'matter') {\r\n        this.bodyType = 'matter';\r\n\r\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\r\n            let bounds = this._raycaster.boundingBox;\r\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\r\n        }\r\n        else {\r\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\r\n        }\r\n\r\n        this.body = this.collisionCircle.body;\r\n        this.body._ray = this;\r\n        this.setOnCollideActive();\r\n    }\r\n    else {\r\n        this.bodyType = 'arcade';\r\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\r\n\r\n        this.body = this.collisionCircle.body;\r\n        this.body\r\n            .setCircle(this.collisionRange)\r\n            .setAllowGravity(false)\r\n            .setImmovable(true);\r\n        this.body._ray = this;\r\n    }\r\n\r\n    return this;\r\n}\r\n","/*Matter physics methods for ray body*/\r\n/**\r\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\r\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\r\n * categories are included in their collision masks (see {@link #setCollidesWith}).\r\n *\r\n * @method Raycaster.Ray#setCollisionCategory\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {number} value - Unique category bitfield.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionCategory(value) {\r\n    this.body.collisionFilter.category = value;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\r\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\r\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\r\n * they will never collide.\r\n *\r\n * @method Raycaster.Ray#setCollisionCategory\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {number} value - Unique group index.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionGroup(value) {\r\n    this.body.collisionFilter.group = value;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\r\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\r\n * and `(categoryB & maskA) !== 0` are both true.*\r\n *\r\n * @method Raycaster.Ray#setCollidesWith\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\n\r\nexport function setCollidesWith(categories) {\r\n    var flags = 0;\r\n\r\n    if (!Array.isArray(categories))\r\n    {\r\n        flags = categories;\r\n    }\r\n    else\r\n    {\r\n        for (var i = 0; i < categories.length; i++)\r\n        {\r\n            flags |= categories[i];\r\n        }\r\n    }\r\n\r\n    this.body.collisionFilter.mask = flags;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollide\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollide(callback) {\r\n    let self = this;\r\n    this.body.onCollideCallback = function(collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            callback(collisionInfo);\r\n        }\r\n        else if(self.processOverlap(collisionInfo)) {\r\n            collisionInfo.rayCollided = true;\r\n            callback(collisionInfo);\r\n        }\r\n    };\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideEnd\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideEnd(callback) {\r\n    this.body.onCollideEndCallback = function(collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            collisionInfo.rayCollided = false;\r\n            callback(collisionInfo);\r\n        }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideActive\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideActive(callback) {\r\n    let self = this;\r\n    let func = function(collisionInfo) {\r\n        if(self.processOverlap(collisionInfo)) {\r\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\r\n\r\n            if(collisionInfo.rayCollided !== true) {\r\n                collisionInfo.rayCollided = true;\r\n                if(self.body.onCollideCallback) {\r\n                    self.body.onCollideCallback(collisionInfo);\r\n                }\r\n\r\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\r\n                    self.body.onCollideWith[body.id](body, collisionInfo);\r\n                }\r\n            }\r\n            if(callback)\r\n                callback(collisionInfo);\r\n        }\r\n        else {\r\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\r\n                self.body.onCollideEndCallback(collisionInfo);\r\n            }\r\n        }\r\n    }\r\n\r\n    this.body.onCollideActiveCallback = func;\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideWith\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\r\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideWith(body, callback) {\r\n    let self = this;\r\n    let func = function(body, collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            callback(body, collisionInfo);\r\n        }\r\n        else if(self.processOverlap(collisionInfo)) {\r\n            collisionInfo.rayCollided = true;\r\n            callback(body, collisionInfo);\r\n        }\r\n    }\r\n\r\n    if (!Array.isArray(body))\r\n    {\r\n        body = [ body ];\r\n    }\r\n\r\n    for (var i = 0; i < body.length; i++)\r\n    {\r\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\r\n\r\n        this.body.setOnCollideWith(src, func);\r\n    }\r\n\r\n    return this;\r\n};\r\n","/**\r\n * Set ray's source position.\r\n *\r\n * @method Raycaster.Ray#setOrigin\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOrigin(x, y) {\r\n    this.origin.setTo(x, y);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\r\n        this.collisionCircle.x = x;\r\n        this.collisionCircle.y = y;\r\n    }\r\n    else if(this.bodyType === 'arcade') {\r\n        this.collisionCircle.x = x;\r\n        this.collisionCircle.y = y;\r\n    }\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Get game objects overlaping field of view.\r\n *\r\n * @method Raycaster.Ray#overlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\r\n *\r\n * @return {object[]} Array of game objects that overlaps with field of view.\r\n */\r\nexport function overlap(objects) {\r\n    let targets = [];\r\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\r\n\r\n    //matter physics\r\n    if(this.bodyType === 'matter') {\r\n        let isCollisionInfo = false;\r\n        if(objects === undefined) {\r\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\r\n\r\n            for(let object of objects) {   \r\n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\r\n\r\n                if(this.testMatterOverlap(body))\r\n                    targets.push(body);\r\n            }\r\n        }\r\n        //get object's body\r\n        else {\r\n            if(!Array.isArray(objects))\r\n                objects = [objects];\r\n            \r\n            for(let object of objects) {\r\n                if(object === this.body)\r\n                    continue;\r\n    \r\n                if(this.testMatterOverlap(object))\r\n                    targets.push(object);\r\n            }\r\n        }\r\n    }\r\n    //arcade physics\r\n    else {\r\n        let bodies = false;\r\n        //get bodies in range\r\n        if(objects === undefined) {\r\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\r\n            bodies = true;\r\n        }\r\n        //get object's body\r\n        else if(!Array.isArray(objects)) {\r\n            objects = [objects];\r\n        }\r\n        //if objects are bodies\r\n        if(bodies) {\r\n            for(let body of objects) {\r\n                if(body === this.body)\r\n                    continue;\r\n            \r\n                let hitbox;\r\n                //get physics body hitbox\r\n                if(body.isCircle) {\r\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\r\n                }\r\n                else {\r\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\r\n                }\r\n\r\n                if(this.testArcadeOverlap(hitbox))\r\n                    targets.push(body.gameObject);\r\n            }\r\n        }\r\n        //if objects are game objects\r\n        else {\r\n            for(let object of objects) {\r\n                if(object.body === undefined)\r\n                    continue;\r\n\r\n                let hitbox;\r\n                //get physics body hitbox\r\n                if(object.body.isCircle) {\r\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\r\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\r\n                        continue;\r\n                }\r\n                else {\r\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\r\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\r\n                        continue;\r\n                }\r\n\r\n                if(this.testArcadeOverlap(hitbox))\r\n                    targets.push(object);\r\n            }\r\n        }\r\n    }\r\n\r\n    return targets;\r\n}\r\n\r\n/**\r\n * Process callback for physics collider / overlap.\r\n *\r\n * @method Raycaster.Ray#processOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\r\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\r\n *\r\n * @return {boolean} Return true if game object is overlapping ray's field of view.\r\n */\r\nexport function processOverlap(object1, object2) {\r\n    let obj1, obj2, target;\r\n    //check if it's matter collisionInfo object\r\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\r\n        obj1 = object1.bodyA;\r\n        obj2 = object1.bodyB;\r\n    }\r\n    else {\r\n        obj1 = object1;\r\n        obj2 = object2;\r\n    }\r\n\r\n    if(obj1._ray !== undefined && obj1._ray === this)\r\n        target = obj2;\r\n    else if(obj2._ray !== undefined && obj2._ray === this)\r\n        target = obj1;\r\n    else\r\n        return false;\r\n\r\n    return (this.overlap(target).length > 0);\r\n}   \r\n\r\n/**\r\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testArcadeOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.8.0\r\n *\r\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testArcadeOverlap(hitbox) {\r\n    let overlap = false;\r\n\r\n    //iterate through field of view slices to check collisions with target\r\n    for(let slice of this.slicedIntersections) {\r\n        //if hitbox is a circle\r\n        if(hitbox.type == 0) {\r\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\r\n        }\r\n        //if hitbox is a rectangle\r\n        else {\r\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\r\n        }\r\n\r\n        if(overlap) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testMatterOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.9.0\r\n *\r\n * @param {object} body - Matter body.\r\n *\r\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testMatterOverlap(object) {\r\n    let body;\r\n\r\n    if(object.type === 'body')\r\n        body = object;\r\n    else if(object.body !== undefined)\r\n        body = object.body;\r\n    else\r\n        return false;\r\n\r\n    //if body is concave, ignore convex body\r\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\r\n    //iterate through bodies\r\n    for(let part of parts) {\r\n        let pointA = part.vertices[0];\r\n\r\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\r\n            let pointB = part.vertices[i];\r\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n\r\n            //iterate through field of view slices to check collisions with target\r\n            for(let slice of this.slicedIntersections) {\r\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\r\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\r\n                if(!overlap)\r\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\r\n                if(!overlap)\r\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\r\n\r\n                if(overlap) {\r\n                    return true;\r\n                }\r\n            }\r\n            pointA = pointB;\r\n        }\r\n\r\n        //closing segment\r\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\r\n         //iterate through field of view slices to check collisions with target\r\n        for(let slice of this.slicedIntersections) {\r\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\r\n\r\n            if(overlap) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n","/**\r\n * Set ray's range.\r\n *\r\n * @method Raycaster.Ray#setRayRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.rayRange = rayRange;\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\r\n * Ray tests all objects when set to 0.\r\n *\r\n * @method Raycaster.Ray#setDetectionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setDetectionRange(detectionRange = 0) {\r\n    this.detectionRange = detectionRange;\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\r\n * Determines ray's physics body radius.\r\n *\r\n * @method Raycaster.Ray#setCollisionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {number} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\r\n    this.collisionRange = collisionRange;\r\n    this.collisionCircle.setRadius(this.collisionRange);\r\n\r\n    if(this.bodyType === 'matter') {\r\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\r\n            let bounds = this._raycaster.boundingBox;\r\n\r\n            this._raycaster.scene.matter.body.set(this.body, {\r\n                shape: {\r\n                    type: 'rectangle',\r\n                    x: bounds.rectangle.centerX,\r\n                    y: bounds.rectangle.centerY,\r\n                    width: bounds.rectangle.width,\r\n                    height: bounds.rectangle.height,\r\n                    circleRadius:0\r\n                }\r\n            });\r\n        }\r\n        else if(oldRangeMax) {\r\n            this._raycaster.scene.matter.body.set(this.body, {\r\n                shape: {\r\n                    type: 'circle',\r\n                    x: this.collisionCircle.x,\r\n                    y: this.collisionCircle.y\r\n                },\r\n                circleRadius: this.collisionRange,\r\n                isStatic: false\r\n            });\r\n        }\r\n        else {\r\n            this.collisionCircle.setRadius(this.collisionRange);\r\n        }\r\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\r\n    }\r\n    else if(this.bodyType === 'arcade') {\r\n        this.body.setCircle(this.collisionRange);\r\n    }\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * Test if object's bounding box is in ray's detection range.\r\n *\r\n * @method Raycaster.Ray#boundsInRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} object - Tested object\r\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\r\n *\r\n * @return {boolean} Information if object is in ray's detection range.\r\n */\r\nexport function boundsInRange(object, bounds = false) {\r\n    if(!this.detectionRange)\r\n        return true;\r\n\r\n    let objectBounds;\r\n    if(bounds)\r\n        objectBounds = bounds;\r\n    else {\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            objectBounds = object.raycasterMap.getBoundingBox();\r\n        else\r\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\r\n    }\r\n\r\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\r\n        return true;\r\n\r\n    return false;\r\n}\r\n","/**\r\n * @classdesc\r\n *\r\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\r\n *\r\n * @namespace Raycaster.Ray\r\n * @class Raycaster.Ray\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Ray(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Ray#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Ray's source position.\r\n    *\r\n    * @name Raycaster.Ray#origin\r\n    * @type {Phaser.Geom.Point}\r\n    * @since 0.6.0\r\n    */\r\n    this.origin = new Phaser.Geom.Point();\r\n    /**\r\n    * Ray's representation used to calculating intersections.\r\n    *\r\n    * @name Raycaster.Ray#_ray\r\n    * @type {Phaser.Geom.Line}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._ray = new Phaser.Geom.Line();\r\n    /**\r\n    * Ray's angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#angle\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.angle = 0;\r\n    /**\r\n    * Ray's cone width angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#cone\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.7.0\r\n    */\r\n    this.cone = 0;\r\n    /**\r\n    * Ray's maximum range\r\n    *\r\n    * @name Raycaster.Ray#rayRange\r\n    * @type {number}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.6.0\r\n    */\r\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\r\n    * Ray tests all objects when set to 0.\r\n    *\r\n    * @name Raycaster.Ray#detectionRange\r\n    * @type {number}\r\n    * @default\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRange = 0;\r\n    /**\r\n    * Ray's representation of detection range used in calculating if objects are in range.\r\n    *\r\n    * @name Raycaster.Ray#detectionRangeCircle\r\n    * @type {Phaser.Geom.Circle}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    /**\r\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\r\n    *\r\n    * @name Raycaster.Ray#collisionRange\r\n    * @type {number}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.8.0\r\n    */\r\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    *\r\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.6.0\r\n    */\r\n    this.ignoreNotIntersectedRays = true;\r\n    /**\r\n    * If set true, ray's hit points will be rounded.\r\n    *\r\n    * @name Raycaster.Ray#round\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.1\r\n    */\r\n    this.round = false;\r\n    /**\r\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    *\r\n    * @name Raycaster.Ray#autoSlice\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.0\r\n    */\r\n    this.autoSlice = false;\r\n    /**\r\n    * Array of intersections from last raycast representing field of view.\r\n    *\r\n    * @name Raycaster.Ray#intersections\r\n    * @type {object[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.intersections = [];\r\n    /**\r\n    * Array of triangles representing slices of field of view from last raycast.\r\n    *\r\n    * @name Raycaster.Ray#slicedIntersections\r\n    * @type {Phaser.Geom.Triangle[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.slicedIntersections = [];\r\n\r\n    /**\r\n    * Physics body for testing field of view collisions.\r\n    *\r\n    * @name Raycaster.Ray#body\r\n    * @type {object}\r\n    * @default undefined\r\n    * @since 0.8.0\r\n    */\r\n    //this.body = false;\r\n    /**\r\n    * Physics body type.\r\n    *\r\n    * @name Raycaster.Ray#bodyType\r\n    * @type {(boolean|'arcade'|'matter')}\r\n    * @default false\r\n    * @since 0.9.0\r\n    */\r\n    this.bodyType = false;\r\n\r\n    /**\r\n    * Ray casting stats.\r\n    *\r\n    * @name Raycaster.Ray#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {string} method Used casting method (cast, castCircle, castCone).\r\n    * @property {number} rays Casted rays.\r\n    * @property {number} testedMappedObjects Tested mapped objects.\r\n    * @property {number} hitMappedObjects Hit mapped objects.\r\n    * @property {number} segments Tested segments.\r\n    * @property {number} time Casting time.\r\n    */\r\n    this._stats = {\r\n        method: 'cast',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    /**\r\n    * Ray's graphics object used for debug\r\n    *\r\n    * @name Raycaster.Ray#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n     this.graphics;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    config: require('./config.js').config,\r\n    getStats: require('./stats.js').getStats,\r\n    setRay: require('./ray.js').setRay,    \r\n    setOrigin: require('./origin.js').setOrigin,\r\n    setRayRange: require('./range.js').setRayRange,\r\n    setAngle: require('./angle.js').setAngle,\r\n    setAngleDeg: require('./angle.js').setAngleDeg,\r\n    setCone: require('./cone.js').setCone,\r\n    setConeDeg: require('./cone.js').setConeDeg,\r\n    setDetectionRange: require('./range.js').setDetectionRange,\r\n    boundsInRange: require('./range.js').boundsInRange,\r\n    cast: require('./cast.js').cast,\r\n    castCircle: require('./castCircle.js').castCircle,\r\n    castCone: require('./castCone.js').castCone,\r\n    slice: require('./slice.js').slice,\r\n    setCollisionRange: require('./range.js').setCollisionRange,\r\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\r\n    overlap: require('./overlap.js').overlap,\r\n    processOverlap: require('./overlap.js').processOverlap,\r\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\r\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\r\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\r\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\r\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\r\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\r\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\r\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\r\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\r\n    drawDebug: require('./debug.js').drawDebug,\r\n    destroy: require('./destroy.js').destroy,\r\n};\r\n","/**\r\n * Set ray's position, direction (angle) and range.\r\n *\r\n * @method Raycaster.Ray#setRay\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} [angle] - Ray's angle in radians.\r\n * @param {number} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.origin.setTo(x, y);\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    this.rayRange = rayRange;\r\n\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\r\n    return this;\r\n}\r\n","/**\r\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\r\n *\r\n * @method Raycaster.Ray#slice\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\r\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\r\n *\r\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\r\n */\r\nexport function slice(intersections = this.intersections, closed = true) {\r\n    //if intersections is Phaser.Geom.Polygon object\r\n    if(!Array.isArray(intersections)) {\r\n        if(intersections.type === 4)\r\n            intersections = intersections.points;\r\n        else\r\n            return [];\r\n    }\r\n\r\n    if(intersections.length === 0)\r\n        return [];\r\n\r\n    let slices = [];\r\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\r\n    }\r\n\r\n    if(closed)\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\r\n\r\n    return slices;\r\n}\r\n","/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2022 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.10.5';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {boolean} [enable = false] Enable debug mode\r\n    * @property {boolean} [maps = true] - Enable maps debug\r\n    * @param {boolean} [rays = true] - Enable rays debug\r\n    * @property {boolean} graphics - Debug graphics options\r\n    * @property {boolean|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {boolean|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds.\r\n    * If world size will change after creation of Raycaster, bounding box needs to be updated.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update.bind(this));\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycaster's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {number} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {number} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {number} width - The width of bounding box.\r\n    * @param {number} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            //if object is not supported\r\n            if(object.data && object.data.get('raycasterMapNotSupported'))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n            \r\n            if(map.notSupported) {\r\n                map.destroy();\r\n                continue;\r\n            }\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats\r\n            if(object.dynamic)\r\n                this._stats.mappedObjects.dynamic++;\r\n            else\r\n                this._stats.mappedObjects.static++;\r\n            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1);\r\n            \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                object.raycasterMap.destroy();\r\n            else\r\n                object.data.get('raycasterMap').destroy();\r\n            \r\n            //update stats\r\n            if(object.dynamic)\r\n                this._stats.mappedObjects.dynamic--;\r\n            else\r\n                this._stats.mappedObjects.static--;\r\n            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        let dynamicMaps = 0;\r\n        if(this.mappedObjects.length > 0) {\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.dynamic) {\r\n                    map.updateMap();\r\n                    dynamicMaps++;\r\n                }\r\n            }\r\n\r\n            //update stats\r\n            this._stats.mappedObjects.static = this.mappedObjects.length - dynamicMaps;\r\n            this._stats.mappedObjects.dynamic = dynamicMaps;\r\n\r\n            //debug\r\n            if(this.debugOptions.enabled)\r\n                this.drawDebug();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray's congfiguration options. May include:\r\n    * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n    * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n    * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n    * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n    * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n    * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n    * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n    * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n    * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n    * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n\r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy object and all mapped objects.\r\n     *\r\n     * @method Raycaster#destroy\r\n     * @memberof Raycaster\r\n     * @instance\r\n     * @since 0.10.3\r\n     */\r\n    destroy: function() {\r\n        this.removeMappedObjects(this.mappedObjects);\r\n\r\n        for(let key in this) {\r\n            delete this[key];\r\n        }\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(880);\n"],"names":["root","factory","exports","module","define","amd","self","PhaserRaycaster","Phaser","Plugins","ScenePlugin","scene","pluginManager","_Raycaster","require","options","this","getBoundingBox","object","getBounds","rectangle","line","polygon","arc","container","tilemap","matterBody","segmentCount","boundingBox","config","undefined","type","getPoints","getSegments","updateMap","circle","setSegmentCount","mapChild","_circles","_updateChildMap","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","notSupported","dynamic","active","destroy","key","raycasterMap","data","remove","ray","_points","length","points","offset","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","c","rayA","Line","rayB","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","_segments","scaleY","geom","segments","newPoints","point","i","isChild","_raycaster","createRay","iterate","child","bind","iLength","list","childA","mapA","get","j","jLength","childB","mapB","Intersects","RectangleToRectangle","segmentA","segmentB","intersection","LineToLine","setDataEnabled","map","constructor","set","childPoints","segment","pointA","getPointA","pointB","vectorA","vectorB","circleOffset","Circle","childMapCircle","Map","raycaster","prototype","body","circleRadius","position","scale","bodies","generateBounds","bounds","bodyItem","parts","vertices","find","segmentIndex","findIndex","x1","y1","x2","y2","splice","closingSegment","matter","composite","Rectangle","min","max","closePath","last","getTopLeft","getTopRight","getBottomRight","getBottomLeft","detectionRange","MAX_SAFE_INTEGER","Distance","Between","LineToCircle","detectionRangeCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","includes","index","leftEdge","vertical","height","width","tileWidth","tileHeight","verticalsLastColumn","column","filter","horizontalSegment","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestSegment","closestObject","closestDistance","internal","startTime","performance","now","stats","method","rays","testedMappedObjects","hitMappedObjects","time","intersections","GetLineToRectangle","distance","target","objects","mappedObjects","result","_boundingBox","setTo","Equals","isTangent","circleIntersections","GetLineToCircle","_stats","ignoreNotIntersectedRays","round","drawDebug","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","previousTarget","castSides","roundedTarget","intersectionA","intersectionB","autoSlice","slicedIntersections","slice","castCone","cone","minAngle","maxAngle","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","abs","setCone","setConeDeg","angleDeg","collisionRange","enablePhysics","debugOptions","enabled","graphics","add","lineStyle","color","fillStyle","setDepth","clear","strokeLineShape","rayPoint","fillPoint","collisionCircle","bodyType","gameObject","shape","centerX","centerY","label","isSensor","ignoreGravity","setOnCollideActive","physics","existing","setCircle","setAllowGravity","setImmovable","setCollisionCategory","value","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","Array","isArray","mask","setOnCollide","callback","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","onCollideActiveCallback","bodyA","bodyB","onCollideWith","id","setOnCollideWith","func","src","hasOwnProperty","overlap","targets","overlapCircle","query","collides","getMatterBodies","testMatterOverlap","overlapCirc","hitbox","isCircle","halfWidth","testArcadeOverlap","CircleToCircle","CircleToRectangle","object1","object2","obj1","obj2","TriangleToCircle","RectangleToTriangle","part","TriangleToLine","Triangle","ContainsPoint","setRayRange","setDetectionRange","setCollisionRange","oldRangeMax","setRadius","isStatic","objectBounds","Ray","getStats","setRay","closed","slices","Raycaster","version","mapPoint","mapSegment","mapBoundingBox","total","static","rectangleMaps","polygonMaps","circleMaps","lineMaps","containerMaps","tilemapMaps","matterMaps","sortedPoints","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","events","on","update","debug","Object","assign","mapGameObjects","setBoundingBox","left","right","option","removeMappedObjects","indexOf","enableMaps","disableMaps","dynamicMaps","mapppedObject","strokeRectShape","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","defineProperty","enumerable","obj","prop","call","r","Symbol","toStringTag"],"sourceRoot":""}