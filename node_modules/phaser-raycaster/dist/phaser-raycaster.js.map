{"version":3,"file":"phaser-raycaster.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAbA,IAeMA,eAAe;EAAA;EAAA;EACjB,yBAAYC,KAAK,EAAEC,aAAa,EAAE;IAAA;IAAA;IAC9B,0BAAMD,KAAK,EAAEC,aAAa;IAE1B,MAAKC,UAAU,GAAGC,qFAAwC;IAAC;EAC/D;;EAEA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAhBI;IAAA;IAAA,OAiBA,2BAA8B;MAAA,IAAdE,OAAO,uEAAG,CAAC,CAAC;MACxBA,OAAO,CAACL,KAAK,GAAG,IAAI,CAACA,KAAK;MAC1B,OAAO,IAAI,IAAI,CAACE,UAAU,CAACG,OAAO,CAAC;IACvC;EAAC;EAAA;AAAA,EA3ByBC,MAAM,CAACC,OAAO,CAACC,WAAW,GA8BxD;AACAC,MAAM,CAACC,OAAO,GAAGX,eAAe;;;;;;;;;;;;;;;AC3DhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASY,cAAc,GAAG;EAC7B,OAAO,IAAI,CAACC,MAAM,CAACC,SAAS,EAAE;AAClC;;;;;;;;;;;;;;;ACbA,IAAIC,SAAS,GAAGX,mBAAO,CAAC,sEAA4B,CAAC;AACrD,IAAIY,IAAI,GAAGZ,mBAAO,CAAC,4DAAuB,CAAC;AAC3C,IAAIa,OAAO,GAAGb,mBAAO,CAAC,kEAA0B,CAAC;AACjD,IAAIc,GAAG,GAAGd,mBAAO,CAAC,gEAAyB,CAAC;AAC5C,IAAIe,SAAS,GAAGf,mBAAO,CAAC,sEAA4B,CAAC;AACrD,IAAIgB,OAAO,GAAGhB,mBAAO,CAAC,kEAA0B,CAAC;AACjD,IAAIiB,UAAU,GAAGjB,mBAAO,CAAC,wEAA6B,CAAC;AACvD,IAAIkB,YAAY,GAAGlB,mBAAO,CAAC,sDAAoB,CAAC;AAChD,IAAImB,WAAW,GAAGnB,mBAAO,CAAC,kDAAkB,CAAC;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASoB,MAAM,CAAClB,OAAO,EAAE;EAC5B,IAAI,CAACO,MAAM,GAAGP,OAAO,CAACO,MAAM;EAC5B;EACA,IAAGP,OAAO,CAACmB,IAAI,KAAKC,SAAS,EACzBpB,OAAO,CAACmB,IAAI,GAAGnB,OAAO,CAACO,MAAM,CAACY,IAAI;EACtC,IAAGnB,OAAO,CAACmB,IAAI,KAAK,MAAM,IAAInB,OAAO,CAACmB,IAAI,KAAK,WAAW,EACtDnB,OAAO,CAACmB,IAAI,GAAG,YAAY;EAC/B,IAAI,CAACA,IAAI,GAAGnB,OAAO,CAACmB,IAAI;EAExB,QAAOnB,OAAO,CAACmB,IAAI;IACf,KAAK,SAAS;MACV,IAAI,CAACE,SAAS,GAAGV,OAAO,CAACU,SAAS;MAClC,IAAI,CAACC,WAAW,GAAGX,OAAO,CAACW,WAAW;MACtC,IAAI,CAAChB,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACiB,SAAS,GAAGZ,OAAO,CAACY,SAAS;MAClC;IACJ,KAAK,KAAK;MACN;MACA,IAAI,CAACP,YAAY,GAAIhB,OAAO,CAACgB,YAAY,GAAIhB,OAAO,CAACgB,YAAY,GAAG,CAAC;MACrE,IAAI,CAACQ,MAAM,GAAIxB,OAAO,CAACgB,YAAY,GAAI,KAAK,GAAG,IAAI;MACnD,IAAI,CAACK,SAAS,GAAGT,GAAG,CAACS,SAAS;MAC9B,IAAI,CAACC,WAAW,GAAGV,GAAG,CAACU,WAAW;MAClC,IAAI,CAAChB,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACiB,SAAS,GAAGX,GAAG,CAACW,SAAS;MAC9B,IAAI,CAACE,eAAe,GAAGT,YAAY,CAACS,eAAe;MACnD;IACJ,KAAK,MAAM;MACP,IAAI,CAACJ,SAAS,GAAGX,IAAI,CAACW,SAAS;MAC/B,IAAI,CAACC,WAAW,GAAGZ,IAAI,CAACY,WAAW;MACnC,IAAI,CAAChB,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACiB,SAAS,GAAGb,IAAI,CAACa,SAAS;MAC/B;IACJ,KAAK,WAAW;MACZ;MACA,IAAI,CAACG,QAAQ,GAAI1B,OAAO,CAAC0B,QAAQ,GAAI1B,OAAO,CAAC0B,QAAQ,GAAG,IAAI;MAC5D;MACA,IAAI,CAACV,YAAY,GAAIhB,OAAO,CAACgB,YAAY,GAAIhB,OAAO,CAACgB,YAAY,GAAG,CAAC;MACrE;MACA,IAAI,CAACW,QAAQ,GAAG,EAAE;MAClB,IAAI,CAACN,SAAS,GAAGR,SAAS,CAACQ,SAAS;MACpC,IAAI,CAACC,WAAW,GAAGT,SAAS,CAACS,WAAW;MACxC,IAAI,CAAChB,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACiB,SAAS,GAAGV,SAAS,CAACU,SAAS;MACpC,IAAI,CAACK,eAAe,GAAGf,SAAS,CAACe,eAAe;MAChD,IAAI,CAACH,eAAe,GAAGT,YAAY,CAACS,eAAe;MACnD;IACJ,KAAK,oBAAoB;MACrB;MACA,IAAI,CAACI,cAAc,GAAI7B,OAAO,CAAC6B,cAAc,GAAI7B,OAAO,CAAC6B,cAAc,GAAG,EAAE;MAC5E,IAAI,CAACR,SAAS,GAAGP,OAAO,CAACO,SAAS;MAClC,IAAI,CAACC,WAAW,GAAGR,OAAO,CAACQ,WAAW;MACtC,IAAI,CAAChB,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACiB,SAAS,GAAGT,OAAO,CAACS,SAAS;MAClC,IAAI,CAACO,iBAAiB,GAAGhB,OAAO,CAACgB,iBAAiB;MAClD;MACA,IAAI,CAACvB,MAAM,CAACwB,SAAS,CAAC,CAAC,EAAC,CAAC,CAAC;MAC1B;IACJ,KAAK,qBAAqB;MACtB;MACA,IAAI,CAACF,cAAc,GAAI7B,OAAO,CAAC6B,cAAc,GAAI7B,OAAO,CAAC6B,cAAc,GAAG,EAAE;MAC5E,IAAI,CAACR,SAAS,GAAGP,OAAO,CAACO,SAAS;MAClC,IAAI,CAACC,WAAW,GAAGR,OAAO,CAACQ,WAAW;MACtC,IAAI,CAAChB,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACiB,SAAS,GAAGT,OAAO,CAACS,SAAS;MAClC,IAAI,CAACO,iBAAiB,GAAGhB,OAAO,CAACgB,iBAAiB;MAClD;MACA,IAAI,CAACvB,MAAM,CAACwB,SAAS,CAAC,CAAC,EAAC,CAAC,CAAC;MAC1B;IACJ,KAAK,cAAc;MACf;MACA,IAAI,CAACF,cAAc,GAAI7B,OAAO,CAAC6B,cAAc,GAAI7B,OAAO,CAAC6B,cAAc,GAAG,EAAE;MAC5E,IAAI,CAACR,SAAS,GAAGP,OAAO,CAACO,SAAS;MAClC,IAAI,CAACC,WAAW,GAAGR,OAAO,CAACQ,WAAW;MACtC,IAAI,CAAChB,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACiB,SAAS,GAAGT,OAAO,CAACS,SAAS;MAClC,IAAI,CAACO,iBAAiB,GAAGhB,OAAO,CAACgB,iBAAiB;MAClD;MACA,IAAI,CAACvB,MAAM,CAACwB,SAAS,CAAC,CAAC,EAAC,CAAC,CAAC;MAC1B;IACJ,KAAK,YAAY;MACb;MACA,IAAI,CAACC,WAAW,GAAIhC,OAAO,CAACgC,WAAW,GAAI,IAAI,GAAG,KAAK;MACvD;MACA,IAAI,CAACC,oBAAoB,GAAIjC,OAAO,CAACiC,oBAAoB,GAAI,IAAI,GAAG,KAAK;MACzE,IAAI,CAACT,MAAM,GAAG,KAAK;MACnB,IAAI,CAACH,SAAS,GAAGN,UAAU,CAACM,SAAS;MACrC,IAAI,CAACC,WAAW,GAAGP,UAAU,CAACO,WAAW;MACzC,IAAI,CAAChB,cAAc,GAAGS,UAAU,CAACT,cAAc;MAC/C,IAAI,CAACiB,SAAS,GAAGR,UAAU,CAACQ,SAAS;MACrC;IACJ;MACI,IAAI,CAACF,SAAS,GAAGZ,SAAS,CAACY,SAAS;MACpC,IAAI,CAACC,WAAW,GAAGb,SAAS,CAACa,WAAW;MACxC,IAAI,CAAChB,cAAc,GAAGW,WAAW,CAACX,cAAc;MAChD,IAAI,CAACiB,SAAS,GAAGd,SAAS,CAACc,SAAS;EAAC;;EAG7C;EACA,IAAG,IAAI,CAACJ,IAAI,IAAI,YAAY,IAAI,OAAO,IAAI,CAACZ,MAAM,CAACC,SAAS,KAAK,UAAU,EAAE;IACzE,IAAI,CAAC0B,YAAY,GAAG,IAAI;EAC5B;;EAEA;EACA,IAAI,CAACC,OAAO,GAAInC,OAAO,CAACmC,OAAO,IAAI,IAAI,GAAI,IAAI,GAAG,KAAK;;EAEvD;EACA,IAAI,CAACC,MAAM,GAAIpC,OAAO,CAACoC,MAAM,KAAKhB,SAAS,GAAIpB,OAAO,CAACoC,MAAM,GAAG,IAAI;EAEpE,OAAO,IAAI;AACf;;;;;;;;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACQ,SAASC,OAAO,GAAG;EACvB;EACA,IAAG,IAAI,CAAC9B,MAAM,CAACY,IAAI,KAAK,MAAM,IAAI,IAAI,CAACZ,MAAM,CAACY,IAAI,KAAK,WAAW,EAAE;IAChE,OAAOZ,MAAM,CAAC+B,YAAY;EAC9B,CAAC,MACI,IAAG,IAAI,CAAC/B,MAAM,CAACgC,IAAI,EAAE;IACtB,IAAI,CAAChC,MAAM,CAACgC,IAAI,CAACC,MAAM,CAAC,cAAc,CAAC;EAC3C;EAEA,KAAI,IAAIC,GAAG,IAAI,IAAI,EAAE;IACjB,OAAO,IAAI,CAACA,GAAG,CAAC;EACpB;AACH;;;;;;;;;;;;;;;;;;;;ACpBD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpB,SAAS,GAAc;EAAA,IAAbqB,GAAG,uEAAG,KAAK;EACjC,IAAG,CAAC,IAAI,CAACN,MAAM,EACX,OAAO,EAAE;EAEb,IAAG,IAAI,CAACO,OAAO,CAACC,MAAM,GAAG,CAAC,EACtB,OAAO,IAAI,CAACD,OAAO;EAEvB,IAAIE,MAAM,GAAG,EAAE;EACf,IAAIC,MAAM,GAAG,IAAI7C,MAAM,CAAC8C,IAAI,CAACC,KAAK,EAAE;EACpCF,MAAM,CAACG,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC0C,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC2C,YAAY,IAAI,IAAI,CAAC3C,MAAM,CAAC4C,OAAO,GAAG,GAAG,CAAC;EACjFL,MAAM,CAACM,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAAC6C,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAAC8C,aAAa,IAAI,IAAI,CAAC9C,MAAM,CAAC+C,OAAO,GAAG,GAAG,CAAC;;EAElF;EACA,IAAGZ,GAAG,EAAE;IACJ,IAAIa,IAAI,GAAG,IAAItD,MAAM,CAAC8C,IAAI,CAACS,IAAI,EAAE;IACjC,IAAIC,IAAI,GAAG,IAAIxD,MAAM,CAAC8C,IAAI,CAACS,IAAI,EAAE;IACjC,IAAIE,CAAC;IAEL,IAAIC,QAAQ,GAAG,IAAI,CAACpD,MAAM,CAACoD,QAAQ;IAEnC,IAAGA,QAAQ,KAAK,CAAC,EAAE;MACf,IAAIC,MAAM,GAAG,IAAI3D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAAC,IAAI,CAACjD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAEN,MAAM,CAACG,CAAC,EAAEH,MAAM,CAACM,CAAC,CAAC;MACnFnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE,IAAI,CAACrD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAEnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAGD,QAAQ,EAAE1D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;MAC7I,IAAII,EAAE,GAAGJ,MAAM,CAACK,SAAS,EAAE;MAC3BP,CAAC,GAAG,IAAIzD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACd,GAAG,CAACwB,MAAM,CAACjB,CAAC,EAAEP,GAAG,CAACwB,MAAM,CAACd,CAAC,EAAEY,EAAE,CAACf,CAAC,EAAEe,EAAE,CAACZ,CAAC,CAAC;IACpE,CAAC,MACI;MACDM,CAAC,GAAG,IAAIzD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACd,GAAG,CAACwB,MAAM,CAACjB,CAAC,EAAEP,GAAG,CAACwB,MAAM,CAACd,CAAC,EAAEN,MAAM,CAACG,CAAC,EAAEH,MAAM,CAACM,CAAC,CAAC;IAC5E;IAEA,IAAIe,SAAS,GAAGC,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAACrE,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACL,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGU,IAAI,CAACE,GAAG,CAAC,IAAI,CAAC/D,MAAM,CAACgE,MAAM,GAAG,IAAI,CAAChE,MAAM,CAACiE,MAAM,EAAE,CAAC,CAAC,CAAC;;IAEzH;IACA,IAAIC,KAAK,GAAGxE,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACJ,CAAC,CAAC;IACrC,IAAIgB,MAAM,GAAGN,IAAI,CAACO,IAAI,CAAE,IAAI,CAACpE,MAAM,CAACgE,MAAM,GAAG,IAAI,CAAChE,MAAM,CAACiE,MAAM,GAAIvE,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACL,CAAC,CAAC,CAAC;IAC9FzD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACN,IAAI,EAAEb,GAAG,CAACwB,MAAM,CAACjB,CAAC,EAAEP,GAAG,CAACwB,MAAM,CAACd,CAAC,EAAEqB,KAAK,GAAGC,MAAM,EAAEP,SAAS,CAAC;IACxFlE,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACJ,IAAI,EAAEf,GAAG,CAACwB,MAAM,CAACjB,CAAC,EAAEP,GAAG,CAACwB,MAAM,CAACd,CAAC,EAAEqB,KAAK,GAAGC,MAAM,EAAEP,SAAS,CAAC;;IAExF;IACAtB,MAAM,CAAC+B,IAAI,CAACrB,IAAI,CAACU,SAAS,EAAE,CAAC;IAC7BpB,MAAM,CAAC+B,IAAI,CAACnB,IAAI,CAACQ,SAAS,EAAE,CAAC;EACjC;EAEA,OAAOpB,MAAM;AACjB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASvB,WAAW,GAAG;EAC1B,IAAG,CAAC,IAAI,CAACc,MAAM,EACX,OAAO,EAAE;EACb,OAAO,IAAI,CAACyC,SAAS;AACzB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAStD,SAAS,GAAG;EACxB,IAAG,CAAC,IAAI,CAACa,MAAM,EACX,OAAO,IAAI;EAEf,IAAG,CAAC,IAAI,CAACpB,YAAY,EAAE;IACnB,IAAI,CAAC2B,OAAO,GAAG,EAAE;IACjB,IAAI,CAACkC,SAAS,GAAG,EAAE;IACnB,OAAO,IAAI;EACf;;EAEA;EACA,IAAI/B,MAAM,GAAG,IAAI7C,MAAM,CAAC8C,IAAI,CAACC,KAAK,EAAE;EACpCF,MAAM,CAACG,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC0C,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC2C,YAAY,GAAG,IAAI,CAAC3C,MAAM,CAAC4C,OAAO,GAAG,IAAI,CAAC5C,MAAM,CAACgE,MAAM,GAAG,IAAI,CAAChE,MAAM,CAACiE,MAAM;EACnH1B,MAAM,CAACM,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAAC6C,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAAC8C,aAAa,GAAG,IAAI,CAAC9C,MAAM,CAAC+C,OAAO,GAAG,IAAI,CAAC/C,MAAM,CAACgE,MAAM,GAAG,IAAI,CAAChE,MAAM,CAACuE,MAAM;;EAEpH;EACA,IAAIjC,MAAM,GAAG,IAAI,CAACtC,MAAM,CAACwE,IAAI,CAAC1D,SAAS,CAAC,IAAI,CAACL,YAAY,CAAC;EAC1D,IAAIgE,QAAQ,GAAG,EAAE;;EAEjB;EACA;EACA,IAAIrB,QAAQ,GAAG,IAAI,CAACpD,MAAM,CAACoD,QAAQ;EACnC,IAAGA,QAAQ,KAAK,CAAC,EAAE;IACf,IAAIsB,SAAS,GAAG,EAAE;IAAC,2CACFpC,MAAM;MAAA;IAAA;MAAvB,oDAAyB;QAAA,IAAjBqC,KAAK;QACT,IAAItB,MAAM,GAAG,IAAI3D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAAC,IAAI,CAACjD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAE,IAAI,CAAC7C,MAAM,CAAC0C,CAAC,GAAG,CAACiC,KAAK,CAACjC,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACgE,MAAM,IAAI,IAAI,CAAChE,MAAM,CAACiE,MAAM,EAAE,IAAI,CAACjE,MAAM,CAAC6C,CAAC,GAAG,CAAC8B,KAAK,CAAC9B,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAACgE,MAAM,IAAI,IAAI,CAAChE,MAAM,CAACuE,MAAM,CAAC;QACzM7E,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE,IAAI,CAACrD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAEnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAGD,QAAQ,EAAE1D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;QAC7IqB,SAAS,CAACL,IAAI,CAAChB,MAAM,CAACK,SAAS,EAAE,CAAC;MACtC;IAAC;MAAA;IAAA;MAAA;IAAA;IACDpB,MAAM,GAAGoC,SAAS;EACtB;EACA;EAAA,KACK;IAAA,4CACgBpC,MAAM;MAAA;IAAA;MAAvB,uDAAyB;QAAA,IAAjBqC,MAAK;QACTA,MAAK,CAACjC,CAAC,GAAGiC,MAAK,CAACjC,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACiE,MAAM,GAAG1B,MAAM,CAACG,CAAC;QACjDiC,MAAK,CAAC9B,CAAC,GAAG8B,MAAK,CAAC9B,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAACuE,MAAM,GAAGhC,MAAM,CAACM,CAAC;MACrD;IAAC;MAAA;IAAA;MAAA;IAAA;EACL;;EAEA;EACA,KAAI,IAAI+B,CAAC,GAAG,CAAC,EAAEvC,MAAM,GAAGC,MAAM,CAACD,MAAM,EAAEuC,CAAC,GAAGvC,MAAM,EAAEuC,CAAC,EAAE,EAAE;IACpD,IAAGA,CAAC,GAAC,CAAC,GAAGvC,MAAM,EACfoC,QAAQ,CAACJ,IAAI,CAAC,IAAI3E,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACX,MAAM,CAACsC,CAAC,CAAC,CAAClC,CAAC,EAAEJ,MAAM,CAACsC,CAAC,CAAC,CAAC/B,CAAC,EAAEP,MAAM,CAACsC,CAAC,GAAC,CAAC,CAAC,CAAClC,CAAC,EAAEJ,MAAM,CAACsC,CAAC,GAAC,CAAC,CAAC,CAAC/B,CAAC,CAAC,CAAC,CAAC,KAE5F4B,QAAQ,CAACJ,IAAI,CAAC,IAAI3E,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACX,MAAM,CAACsC,CAAC,CAAC,CAAClC,CAAC,EAAEJ,MAAM,CAACsC,CAAC,CAAC,CAAC/B,CAAC,EAAEP,MAAM,CAAC,CAAC,CAAC,CAACI,CAAC,EAAEJ,MAAM,CAAC,CAAC,CAAC,CAACO,CAAC,CAAC,CAAC;EAC3F;EAEA,IAAI,CAACT,OAAO,GAAGE,MAAM;EACrB,IAAI,CAACgC,SAAS,GAAGG,QAAQ;EACzB,OAAO,IAAI;AACf;AAAC;;;;;;;;;;;;;;;;;;;;;AC5ID;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAS3D,SAAS,GAA+B;EAAA,IAA9BqB,GAAG,uEAAG,KAAK;EAAA,IAAE0C,OAAO,uEAAG,KAAK;EAClD,IAAG,CAAC,IAAI,CAAChD,MAAM,EACX,OAAO,EAAE;EAEb,IAAIS,MAAM,GAAG,IAAI,CAACF,OAAO;EACzB;EACA,IAAIG,MAAM,GAAG,IAAI7C,MAAM,CAAC8C,IAAI,CAACC,KAAK,EAAE;EACpCF,MAAM,CAACG,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC0C,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC2C,YAAY,GAAG,IAAI,CAAC3C,MAAM,CAAC4C,OAAO;EACzEL,MAAM,CAACM,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAAC6C,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAAC8C,aAAa,GAAG,IAAI,CAAC9C,MAAM,CAAC+C,OAAO;;EAE1E;EACA,IAAG,IAAI,CAACtC,YAAY,IAAI,CAAC,IAAI,CAACoE,OAAO,EAAE;IACnC,IAAG1C,GAAG,EAAE;MACJ;MACA,IAAIkB,MAAM,GAAG,IAAI3D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAAC,CAAC,EAAE,CAAC,EAAEd,GAAG,CAACwB,MAAM,CAACjB,CAAC,GAAGH,MAAM,CAACG,CAAC,EAAEP,GAAG,CAACwB,MAAM,CAACd,CAAC,GAAGN,MAAM,CAACM,CAAC,CAAC;MACzFnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE3D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAG,IAAI,CAACrD,MAAM,CAACoD,QAAQ,EAAE1D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;MAEjI,IAAIyB,OAAO,GAAG3C,GAAG,CAAC4C,UAAU,CAACC,SAAS,CAAC;QACnCrB,MAAM,EAAE;UACJjB,CAAC,EAAEW,MAAM,CAACK,SAAS,EAAE,CAAChB,CAAC;UACvBG,CAAC,EAAEQ,MAAM,CAACK,SAAS,EAAE,CAACb;QAC1B;MACJ,CAAC,CAAC;;MAEF;MACA,IAAIG,IAAI,GAAG,IAAItD,MAAM,CAAC8C,IAAI,CAACS,IAAI,EAAE;MACjC,IAAIC,IAAI,GAAG,IAAIxD,MAAM,CAAC8C,IAAI,CAACS,IAAI,EAAE;MACjC,IAAIE,CAAC;MAAC,2CAEY,IAAI,CAAC/B,QAAQ;QAAA;MAAA;QAA/B,oDAAiC;UAAA,IAAzBH,MAAM;UACVA,MAAM,CAACqB,MAAM,GAAG,EAAE;UAClBa,CAAC,GAAG,IAAIzD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACd,GAAG,CAACwB,MAAM,CAACjB,CAAC,EAAEP,GAAG,CAACwB,MAAM,CAACd,CAAC,EAAE5B,MAAM,CAACyB,CAAC,EAAEzB,MAAM,CAAC4B,CAAC,CAAC;UAExE,IAAIe,SAAS,GAAGC,IAAI,CAACC,IAAI,CAACD,IAAI,CAACE,GAAG,CAACrE,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACL,CAAC,CAAC,EAAE,CAAC,CAAC,GAAGU,IAAI,CAACE,GAAG,CAAC9C,MAAM,CAAC+C,MAAM,EAAE,CAAC,CAAC,CAAC;;UAE/F;UACA,IAAIE,KAAK,GAAGxE,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACJ,CAAC,CAAC;UACrC,IAAIgB,MAAM,GAAGN,IAAI,CAACO,IAAI,CAAEnD,MAAM,CAAC+C,MAAM,GAAItE,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACL,CAAC,CAAC,CAAC;UACpEzD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACN,IAAI,EAAEb,GAAG,CAACwB,MAAM,CAACjB,CAAC,EAAEP,GAAG,CAACwB,MAAM,CAACd,CAAC,EAAEqB,KAAK,GAAGC,MAAM,EAAEP,SAAS,CAAC;UACxFlE,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACJ,IAAI,EAAEf,GAAG,CAACwB,MAAM,CAACjB,CAAC,EAAEP,GAAG,CAACwB,MAAM,CAACd,CAAC,EAAEqB,KAAK,GAAGC,MAAM,EAAEP,SAAS,CAAC;;UAExF;UACA3C,MAAM,CAACqB,MAAM,CAAC+B,IAAI,CAACrB,IAAI,CAACU,SAAS,EAAE,CAAC;UACpCzC,MAAM,CAACqB,MAAM,CAAC+B,IAAI,CAACnB,IAAI,CAACQ,SAAS,EAAE,CAAC;UACpCpB,MAAM,CAAC+B,IAAI,CAACrB,IAAI,CAACU,SAAS,EAAE,CAAC;UAC7BpB,MAAM,CAAC+B,IAAI,CAACnB,IAAI,CAACQ,SAAS,EAAE,CAAC;QACjC;MAAC;QAAA;MAAA;QAAA;MAAA;IACL;EACJ;EAEA,OAAOpB,MAAM;AACjB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASvB,WAAW,GAAG;EAC1B,IAAG,CAAC,IAAI,CAACc,MAAM,EACX,OAAO,EAAE;EAEb,OAAO,IAAI,CAACyC,SAAS;AACzB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAStD,SAAS,GAAG;EACxB,IAAG,CAAC,IAAI,CAACa,MAAM,EACX,OAAO,IAAI;EAEf,IAAIS,MAAM,GAAG,EAAE;EACf,IAAImC,QAAQ,GAAG,EAAE;EACjB,IAAInE,SAAS,GAAG,IAAI,CAACN,MAAM;EAC3B,IAAI,CAACoB,QAAQ,GAAG,EAAE;;EAElB;EACA,IAAImB,MAAM,GAAG,IAAI7C,MAAM,CAAC8C,IAAI,CAACC,KAAK,EAAE;EACpCF,MAAM,CAACG,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC0C,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAAC2C,YAAY,GAAG,IAAI,CAAC3C,MAAM,CAAC4C,OAAO;EACzEL,MAAM,CAACM,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAAC6C,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAAC8C,aAAa,GAAG,IAAI,CAAC9C,MAAM,CAAC+C,OAAO;EAE1E,IAAIK,QAAQ,GAAG9C,SAAS,CAAC8C,QAAQ;EAEjC,IAAG,IAAI,CAACjC,QAAQ,EAAE;IACd,IAAI,CAACE,eAAe,CAAC,IAAI,CAACF,QAAQ,EAAEmB,MAAM,EAAEmC,QAAQ,EAAErB,QAAQ,EAAEb,MAAM,CAAC;EAC3E,CAAC,MACI;IACD;IACAjC,SAAS,CAAC2E,OAAO,CAAC,UAASC,KAAK,EAAC;MAC7B,IAAI,CAAC7D,eAAe,CAAC6D,KAAK,EAAE5C,MAAM,EAAEmC,QAAQ,EAAErB,QAAQ,EAAEb,MAAM,CAAC;IACnE,CAAC,CAAC4C,IAAI,CAAC,IAAI,CAAC,CAAC;;IAEb;IACA,KAAI,IAAIP,CAAC,GAAG,CAAC,EAAEQ,OAAO,GAAG9E,SAAS,CAAC+E,IAAI,CAAChD,MAAM,EAAEuC,CAAC,GAAGQ,OAAO,EAAER,CAAC,EAAE,EAAC;MAC7D,IAAIU,MAAM,GAAGhF,SAAS,CAAC+E,IAAI,CAACT,CAAC,CAAC;MAC9B,IAAIW,IAAI,GAAGD,MAAM,CAACtD,IAAI,CAACwD,GAAG,CAAC,cAAc,CAAC;MAE1C,IAAG,CAACD,IAAI,EACJ;MAEJ,KAAI,IAAIE,CAAC,GAAGb,CAAC,GAAC,CAAC,EAAEc,OAAO,GAAGpF,SAAS,CAAC+E,IAAI,CAAChD,MAAM,EAAEoD,CAAC,GAAGC,OAAO,EAAED,CAAC,EAAE,EAAC;QAC/D,IAAIE,MAAM,GAAGrF,SAAS,CAAC+E,IAAI,CAACI,CAAC,CAAC;QAC9B,IAAIG,IAAI,GAAGD,MAAM,CAAC3D,IAAI,CAACwD,GAAG,CAAC,cAAc,CAAC;QAC1C;QACA,IAAG,CAACI,IAAI,IAAI,CAAClG,MAAM,CAAC8C,IAAI,CAACqD,UAAU,CAACC,oBAAoB,CAACR,MAAM,CAACrF,SAAS,EAAE,EAAE0F,MAAM,CAAC1F,SAAS,EAAE,CAAC,EAC5F;;QAEJ;QAAA,4CACoBsF,IAAI,CAACxE,WAAW,EAAE;UAAA;QAAA;UAAtC,uDAAwC;YAAA,IAAhCgF,QAAQ;YAAA,4CACQH,IAAI,CAAC7E,WAAW,EAAE;cAAA;YAAA;cAAtC,uDAAwC;gBAAA,IAAhCiF,QAAQ;gBACZ,IAAIC,YAAY,GAAG,EAAE;gBACrB,IAAG,CAACvG,MAAM,CAAC8C,IAAI,CAACqD,UAAU,CAACK,UAAU,CAACH,QAAQ,EAAEC,QAAQ,EAAEC,YAAY,CAAC,EACnE;;gBAEJ;gBACA,IAAG7C,QAAQ,KAAK,CAAC,EAAE;kBACf,IAAIC,MAAM,GAAG,IAAI3D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAAC3C,SAAS,CAACoC,CAAC,EAAEpC,SAAS,CAACuC,CAAC,EAAEoD,YAAY,CAACvD,CAAC,GAAGpC,SAAS,CAAC2D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEuD,YAAY,CAACpD,CAAC,GAAGvC,SAAS,CAACiE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC;kBACvJnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE,IAAI,CAACrD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAEnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAGD,QAAQ,EAAE1D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;kBAC7If,MAAM,CAAC+B,IAAI,CAAChB,MAAM,CAACK,SAAS,EAAE,CAAC;gBACnC;gBACA;gBAAA,KAEIpB,MAAM,CAAC+B,IAAI,CAAC,IAAI3E,MAAM,CAAC8C,IAAI,CAACC,KAAK,CAACwD,YAAY,CAACvD,CAAC,GAAGpC,SAAS,CAAC2D,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEuD,YAAY,CAACpD,CAAC,GAAGvC,SAAS,CAAC2D,MAAM,GAAG1B,MAAM,CAACM,CAAC,CAAC,CAAC;cACtI;YAAC;cAAA;YAAA;cAAA;YAAA;UACL;QAAC;UAAA;QAAA;UAAA;QAAA;MACL;IACJ;EACJ;EAEA,IAAI,CAACT,OAAO,GAAGE,MAAM;EACrB,IAAI,CAACgC,SAAS,GAAGG,QAAQ;EAEzB,OAAO,IAAI;AACf;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASpD,eAAe,CAAC6D,KAAK,EAAE5C,MAAM,EAAEmC,QAAQ,EAAErB,QAAQ,EAAEb,MAAM,EAAE;EACvE,IAAG,CAAC2C,KAAK,CAAClD,IAAI,EACVkD,KAAK,CAACiB,cAAc,EAAE;;EAE1B;EACA,IAAGjB,KAAK,CAAClD,IAAI,CAACwD,GAAG,CAAC,0BAA0B,CAAC,EACzC;;EAEJ;EACA,IAAIY,GAAG,GAAGlB,KAAK,CAAClD,IAAI,CAACwD,GAAG,CAAC,cAAc,CAAC;EACxC,IAAG,CAACY,GAAG,EAAE;IACLA,GAAG,GAAG,IAAI,IAAI,CAACC,WAAW,CAAC;MACvBrG,MAAM,EAAEkF,KAAK;MACbzE,YAAY,EAAE,IAAI,CAACA;IACvB,CAAC,CAAC;IAEF,IAAG2F,GAAG,CAACzE,YAAY,EAAE;MACjByE,GAAG,CAACtE,OAAO,EAAE;MACboD,KAAK,CAAClD,IAAI,CAACsE,GAAG,CAAC,0BAA0B,EAAE,IAAI,CAAC;MAChD;IACJ;IAEApB,KAAK,CAAClD,IAAI,CAACsE,GAAG,CAAC,cAAc,EAAEF,GAAG,CAAC;EACvC,CAAC,MAEGA,GAAG,CAACpF,SAAS,EAAE;;EAEnB;EACA,IAAIuF,WAAW,GAAG,EAAE;EAAC,4CACJH,GAAG,CAACtF,SAAS,CAAC,KAAK,EAAE,IAAI,CAAC;IAAA;EAAA;IAA3C,uDAA6C;MAAA,IAArC6D,KAAK;MACT;MACA,IAAGvB,QAAQ,KAAK,CAAC,EAAE;QACf,IAAIC,QAAM,GAAG,IAAI3D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAAC,IAAI,CAACjD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAE8B,KAAK,CAACjC,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACiE,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEiC,KAAK,CAAC9B,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAACuE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC;QACjJnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,QAAM,EAAE,IAAI,CAACrD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAEnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,QAAM,CAAC,GAAGD,QAAQ,EAAE1D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,QAAM,CAAC,CAAC;QAC7If,MAAM,CAAC+B,IAAI,CAAChB,QAAM,CAACK,SAAS,EAAE,CAAC;MACnC;MACA;MAAA,KAEIpB,MAAM,CAAC+B,IAAI,CAAC,IAAI3E,MAAM,CAAC8C,IAAI,CAACC,KAAK,CAACkC,KAAK,CAACjC,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACiE,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEiC,KAAK,CAAC9B,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAACiE,MAAM,GAAG1B,MAAM,CAACM,CAAC,CAAC,CAAC;MAExH0D,WAAW,CAAClC,IAAI,CAAC/B,MAAM,CAACA,MAAM,CAACD,MAAM,GAAG,CAAC,CAAC,CAAC;IAC/C;;IAEA;EAAA;IAAA;EAAA;IAAA;EAAA;EAAA,4CACmB+D,GAAG,CAACrF,WAAW,EAAE;IAAA;EAAA;IAApC,uDAAsC;MAAA,IAA9ByF,OAAO;MACX;MACA,IAAGpD,QAAQ,KAAK,CAAC,EAAE;QACf,IAAIqD,MAAM,GAAGD,OAAO,CAACE,SAAS,EAAE;QAChC,IAAIC,MAAM,GAAGH,OAAO,CAAC9C,SAAS,EAAE;QAChC,IAAIkD,OAAO,GAAG,IAAIlH,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAAC,IAAI,CAACjD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAE4D,MAAM,CAAC/D,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACiE,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAE+D,MAAM,CAAC5D,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAACuE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC;QACpJ,IAAIgE,OAAO,GAAG,IAAInH,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAAC,IAAI,CAACjD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAE8D,MAAM,CAACjE,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACiE,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAEiE,MAAM,CAAC9D,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAACuE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC;QACpJnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACsD,OAAO,EAAE,IAAI,CAAC5G,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAEnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACqD,OAAO,CAAC,GAAGxD,QAAQ,EAAE1D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACoD,OAAO,CAAC,CAAC;QAChJlH,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACuD,OAAO,EAAE,IAAI,CAAC7G,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAEnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACsD,OAAO,CAAC,GAAGzD,QAAQ,EAAE1D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACqD,OAAO,CAAC,CAAC;QAEhJpC,QAAQ,CAACJ,IAAI,CAAC,IAAI3E,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAAC2D,OAAO,CAAClD,SAAS,EAAE,CAAChB,CAAC,EAAEkE,OAAO,CAAClD,SAAS,EAAE,CAACb,CAAC,EAAEgE,OAAO,CAACnD,SAAS,EAAE,CAAChB,CAAC,EAAEmE,OAAO,CAACnD,SAAS,EAAE,CAACb,CAAC,CAAC,CAAC;MACnI;MACA;MAAA,KAEI4B,QAAQ,CAACJ,IAAI,CAAC,IAAI3E,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACuD,OAAO,CAACE,SAAS,EAAE,CAAChE,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACiE,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAE8D,OAAO,CAACE,SAAS,EAAE,CAAC7D,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAACuE,MAAM,GAAGhC,MAAM,CAACM,CAAC,EAAE2D,OAAO,CAAC9C,SAAS,EAAE,CAAChB,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACiE,MAAM,GAAG1B,MAAM,CAACG,CAAC,EAAE8D,OAAO,CAAC9C,SAAS,EAAE,CAACb,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAACuE,MAAM,GAAGhC,MAAM,CAACM,CAAC,CAAC,CAAC;IACvQ;;IAEA;EAAA;IAAA;EAAA;IAAA;EAAA;EACA,IAAGuD,GAAG,CAACxF,IAAI,IAAI,KAAK,IAAI,IAAI,CAACH,YAAY,IAAI,CAAC,EAAE;IAC5C,IAAIqG,YAAY,GAAG,IAAIpH,MAAM,CAAC8C,IAAI,CAACC,KAAK,EAAE;IAC1CqE,YAAY,CAACpE,CAAC,GAAG,CAAC0D,GAAG,CAACpG,MAAM,CAAC0C,CAAC,GAAG0D,GAAG,CAACpG,MAAM,CAAC2C,YAAY,IAAIyD,GAAG,CAACpG,MAAM,CAAC4C,OAAO,GAAG,GAAG,CAAC,IAAI,IAAI,CAAC5C,MAAM,CAACiE,MAAM,GAAG1B,MAAM,CAACG,CAAC;IACtHoE,YAAY,CAACjE,CAAC,GAAG,CAACuD,GAAG,CAACpG,MAAM,CAAC6C,CAAC,GAAGuD,GAAG,CAACpG,MAAM,CAAC8C,aAAa,IAAIsD,GAAG,CAACpG,MAAM,CAAC+C,OAAO,GAAG,GAAG,CAAC,IAAK,IAAI,CAAC/C,MAAM,CAACuE,MAAM,GAAGhC,MAAM,CAACM,CAAC;IAExH,IAAGO,QAAQ,KAAK,CAAC,EAAE;MACf,IAAIC,MAAM,GAAG,IAAI3D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAAC,IAAI,CAACjD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAEiE,YAAY,CAACpE,CAAC,EAAEoE,YAAY,CAACjE,CAAC,CAAC;MAC/FnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,MAAM,EAAE,IAAI,CAACrD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAEnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,MAAM,CAAC,GAAGD,QAAQ,EAAE1D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,MAAM,CAAC,CAAC;MAC7IyD,YAAY,GAAGzD,MAAM,CAACK,SAAS,EAAE;IACrC;IAEA,IAAI,CAACtC,QAAQ,CAACiD,IAAI,CAAC,IAAI3E,MAAM,CAAC8C,IAAI,CAACuE,MAAM,CAACD,YAAY,CAACpE,CAAC,EAAEoE,YAAY,CAACjE,CAAC,EAAEuD,GAAG,CAACpG,MAAM,CAACgE,MAAM,GAAGoC,GAAG,CAACpG,MAAM,CAACiE,MAAM,GAAG,IAAI,CAACjE,MAAM,CAACiE,MAAM,CAAC,CAAC;EAC1I,CAAC,MACI,IAAGmC,GAAG,CAACxF,IAAI,KAAK,WAAW,EAAE;IAAA,4CACJwF,GAAG,CAAChF,QAAQ;MAAA;IAAA;MAAtC,uDAAwC;QAAA,IAAhC4F,cAAc;QAClB,IAAIF,aAAY,GAAG,IAAIpH,MAAM,CAAC8C,IAAI,CAACC,KAAK,EAAE;QACtCqE,aAAY,CAACpE,CAAC,GAAGsE,cAAc,CAACtE,CAAC,GAAG,IAAI,CAAC1C,MAAM,CAACiE,MAAM,GAAG1B,MAAM,CAACG,CAAC;QACjEoE,aAAY,CAACjE,CAAC,GAAGmE,cAAc,CAACnE,CAAC,GAAG,IAAI,CAAC7C,MAAM,CAACuE,MAAM,GAAGhC,MAAM,CAACM,CAAC;QAErE,IAAGO,QAAQ,KAAK,CAAC,EAAE;UACf,IAAIC,OAAM,GAAG,IAAI3D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAAC,IAAI,CAACjD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAEiE,aAAY,CAACpE,CAAC,EAAEoE,aAAY,CAACjE,CAAC,CAAC;UAC/FnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACK,UAAU,CAACD,OAAM,EAAE,IAAI,CAACrD,MAAM,CAAC0C,CAAC,EAAE,IAAI,CAAC1C,MAAM,CAAC6C,CAAC,EAAEnD,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACM,KAAK,CAACF,OAAM,CAAC,GAAGD,QAAQ,EAAE1D,MAAM,CAAC8C,IAAI,CAACS,IAAI,CAACO,MAAM,CAACH,OAAM,CAAC,CAAC;UAC7IyD,aAAY,GAAGzD,OAAM,CAACK,SAAS,EAAE;QACrC;QAEA,IAAI,CAACtC,QAAQ,CAACiD,IAAI,CAAC,IAAI3E,MAAM,CAAC8C,IAAI,CAACuE,MAAM,CAACD,aAAY,CAACpE,CAAC,EAAEoE,aAAY,CAACjE,CAAC,EAAEmE,cAAc,CAAChD,MAAM,GAAG,IAAI,CAAChE,MAAM,CAACiE,MAAM,CAAC,CAAC;MAC1H;IAAC;MAAA;IAAA;MAAA;IAAA;EACL;AACJ;;;;;;;;;;;;;;;AC9QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASgD,GAAG,CAACxH,OAAO,EAAEyH,SAAS,EAAE;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACnC,UAAU,GAAGmC,SAAS,GAAGA,SAAS,GAAG,KAAK;EAC/C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACtG,IAAI;EACT;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiB,MAAM;EACX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACD,OAAO;EACZ;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACX,MAAM,GAAG,KAAK;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACjB,MAAM;EACX;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACoC,OAAO,GAAG,EAAE;EACjB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACkC,SAAS,GAAG,EAAE;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACxD,SAAS;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACC,WAAW;EAChB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAChB,cAAc;EACnB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiB,SAAS;EAEd,IAAI,CAACL,MAAM,CAAClB,OAAO,CAAC;EACpB,IAAG,CAAC,IAAI,CAACkC,YAAY,EACjB,IAAI,CAACX,SAAS,EAAE;EAEpB,OAAO,IAAI;AACf;AAAC;AAEDiG,GAAG,CAACE,SAAS,GAAG;EACZxG,MAAM,EAAEpB,sEAA6B;EACrCuC,OAAO,EAAEvC,yEAA+BuC;AAC5C,CAAC;AAEDmF,GAAG,CAACE,SAAS,CAACd,WAAW,GAAGY,GAAG;;;;;;;;;;;;;;;;;ACnJ/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASnG,SAAS,GAAc;EAAA,IAAbqB,GAAG,uEAAG,KAAK;EACjC,IAAG,CAAC,IAAI,CAACN,MAAM,EACX,OAAO,EAAE;EACb,OAAO,IAAI,CAACO,OAAO;AACvB;AAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASrB,WAAW,GAAG;EAC1B,IAAG,CAAC,IAAI,CAACc,MAAM,EACX,OAAO,EAAE;EACb,OA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;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAASC,GAAG,CAACpV,OAAO,EAAEyH,SAAS,EAAE;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACnC,UAAU,GAAGmC,SAAS,GAAGA,SAAS,GAAG,KAAK;EAC/C;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACvD,MAAM,GAAG,IAAIjE,MAAM,CAAC8C,IAAI,CAACC,KAAK,EAAE;EACrC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACsI,IAAI,GAAG,IAAIrL,MAAM,CAAC8C,IAAI,CAACS,IAAI,EAAE;EAClC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiB,KAAK,GAAG,CAAC;EACd;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACoK,IAAI,GAAG,CAAC;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACtD,QAAQ,GAAGtL,MAAM,CAACmE,IAAI,CAACsF,gBAAgB;EAC5C;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACD,cAAc,GAAG,CAAC;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACK,oBAAoB,GAAG,IAAI7J,MAAM,CAAC8C,IAAI,CAACuE,MAAM,EAAE;EACpD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACmI,cAAc,GAAGxP,MAAM,CAACmE,IAAI,CAACsF,gBAAgB;EAClD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC6D,wBAAwB,GAAG,IAAI;EACpC;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACC,KAAK,GAAG,KAAK;EAClB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACiB,SAAS,GAAG,KAAK;EACt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ACtB;;;;;;;;;;;;;;;;;;;AChBD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACO,SAAStN,SAAS,CAACC,OAAO,EAAE;EAC/B;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACyV,OAAO,GAAG,QAAQ;EACvB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC9V,KAAK;EACV;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACkQ,QAAQ;EACb;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACF,YAAY,GAAG;IAChBC,OAAO,EAAE,KAAK;IACdhC,IAAI,EAAE,IAAI;IACVvB,IAAI,EAAE,IAAI;IACVwD,QAAQ,EAAE;MACNnN,GAAG,EAAE,QAAQ;MACb2N,QAAQ,EAAE,QAAQ;MAClBqF,QAAQ,EAAE,QAAQ;MAClBC,UAAU,EAAE,QAAQ;MACpBC,cAAc,EAAE;IACpB;EACJ,CAAC;;EAED;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACK,IAAI,CAACvI,MAAM,GAAG;IACXP,aAAa,EAAE;MACX+I,KAAK,EAAE,CAAC;MACRC,MAAM,EAAE,CAAC;MACT3T,OAAO,EAAE,CAAC;MACV4T,aAAa,EAAE,CAAC;MAChBC,WAAW,EAAE,CAAC;MACdC,UAAU,EAAE,CAAC;MACbC,QAAQ,EAAE,CAAC;MACXC,aAAa,EAAE,CAAC;MAChBC,WAAW,EAAE,CAAC;MACdC,UAAU,EAAE;IAChB;EACH,CAAC;;EAEF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAACpV,WAAW,GAAG,KAAK;EACxB;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAI,CAAC6L,aAAa,GA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","sources":["webpack://PhaserRaycaster/webpack/universalModuleDefinition","webpack://PhaserRaycaster/./src/main.js","webpack://PhaserRaycaster/./src/map/boundingBox.js","webpack://PhaserRaycaster/./src/map/config.js","webpack://PhaserRaycaster/./src/map/destroy.js","webpack://PhaserRaycaster/./src/map/map-circle-methods.js","webpack://PhaserRaycaster/./src/map/map-container-methods.js","webpack://PhaserRaycaster/./src/map/map-core.js","webpack://PhaserRaycaster/./src/map/map-line-methods.js","webpack://PhaserRaycaster/./src/map/map-matterBody-methods.js","webpack://PhaserRaycaster/./src/map/map-polygon-methods.js","webpack://PhaserRaycaster/./src/map/map-rectangle-methods.js","webpack://PhaserRaycaster/./src/map/map-tilemap-methods.js","webpack://PhaserRaycaster/./src/map/segmentsCount.js","webpack://PhaserRaycaster/./src/ray/angle.js","webpack://PhaserRaycaster/./src/ray/cast.js","webpack://PhaserRaycaster/./src/ray/castCircle.js","webpack://PhaserRaycaster/./src/ray/castCone.js","webpack://PhaserRaycaster/./src/ray/cone.js","webpack://PhaserRaycaster/./src/ray/config.js","webpack://PhaserRaycaster/./src/ray/debug.js","webpack://PhaserRaycaster/./src/ray/destroy.js","webpack://PhaserRaycaster/./src/ray/enablePhysics.js","webpack://PhaserRaycaster/./src/ray/matter-physics-methods.js","webpack://PhaserRaycaster/./src/ray/origin.js","webpack://PhaserRaycaster/./src/ray/overlap.js","webpack://PhaserRaycaster/./src/ray/range.js","webpack://PhaserRaycaster/./src/ray/ray-core.js","webpack://PhaserRaycaster/./src/ray/ray.js","webpack://PhaserRaycaster/./src/ray/slice.js","webpack://PhaserRaycaster/./src/ray/stats.js","webpack://PhaserRaycaster/./src/raycaster-core.js","webpack://PhaserRaycaster/webpack/bootstrap","webpack://PhaserRaycaster/webpack/runtime/define property getters","webpack://PhaserRaycaster/webpack/runtime/hasOwnProperty shorthand","webpack://PhaserRaycaster/webpack/runtime/make namespace object","webpack://PhaserRaycaster/webpack/before-startup","webpack://PhaserRaycaster/webpack/startup","webpack://PhaserRaycaster/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"PhaserRaycaster\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"PhaserRaycaster\"] = factory();\n\telse\n\t\troot[\"PhaserRaycaster\"] = factory();\n})(self, function() {\nreturn ","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2022 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * Point object\r\n * @typedef {Object} Point\r\n * @property {number} x\r\n * @property {number} y\r\n */\r\n \r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster plugin class.\r\n * \r\n * @namespace PhaserRaycaster\r\n * @class PhaserRaycaster\r\n * @extends Phaser.Plugins.ScenePlugin\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {Phaser.Scene} scene\r\n * @param {Phaser.Plugins.PluginManager} pluginManager\r\n */\r\n\r\nclass PhaserRaycaster extends Phaser.Plugins.ScenePlugin {\r\n    constructor(scene, pluginManager) {\r\n        super(scene, pluginManager);\r\n\r\n        this._Raycaster = require('./raycaster-core.js').Raycaster;\r\n    }\r\n\r\n    /**\r\n    * Create Raycaster object.\r\n    *\r\n    * @method PhaserRaycaster#createRaycaster\r\n    * @memberof PhaserRaycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n    * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    createRaycaster(options = {}) {\r\n        options.scene = this.scene;\r\n        return new this._Raycaster(options);\r\n    }\r\n}\r\n\r\n//Make sure you export the plugin for webpack to expose\r\nmodule.exports = PhaserRaycaster;","/**\r\n* Get mapped object's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Mapped object's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    return this.object.getBounds();\r\n}\r\n","let rectangle = require('./map-rectangle-methods.js');\r\nlet line = require('./map-line-methods.js');\r\nlet polygon = require('./map-polygon-methods.js');\r\nlet arc = require('./map-circle-methods.js');\r\nlet container = require('./map-container-methods.js');\r\nlet tilemap = require('./map-tilemap-methods.js');\r\nlet matterBody = require('./map-matterBody-methods.js');\r\nlet segmentCount = require('./segmentsCount.js');\r\nlet boundingBox = require('./boundingBox.js');\r\n\r\n/**\r\n * Configure map.\r\n *\r\n * @method Raycaster.Map#config\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Map's congfiguration options. May include:\r\n * @param {object} options.object - Game object to map\r\n * @param {string} [options.type] - Map type. If not defined, it will be determined based on object.\r\n * @param {boolean} [options.dynamic = false] - If set true, map will be dynamic (updated on scene update event).\r\n * @param {boolean} [options.active = true] - If set true, map will be active (will provide points, segments and will be updated).\r\n * @param {number} [options.segmentCount] - Circle map's segment count. If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n * @param {object} [options.mapChild] - Container's child. If set, only set child will be mapped.\r\n * @param {boolean} [options.forceConvex] - If set true, matter body map will use convex body (hull) for non-covex bodies.\r\n * @param {boolean} [options.forceVerticesMapping] - If set true, matter body map will use only vertices for mapping circle bodies.\r\n * \r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //object type\r\n    if(options.type === undefined)\r\n        options.type = options.object.type;\r\n    if(options.type === 'body' || options.type === 'composite')\r\n        options.type = 'MatterBody';\r\n    this.type = options.type;\r\n    \r\n    switch(options.type) {\r\n        case 'Polygon':\r\n            this.getPoints = polygon.getPoints;\r\n            this.getSegments = polygon.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = polygon.updateMap;\r\n            break;\r\n        case 'Arc':\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            this.circle = (options.segmentCount) ? false : true;\r\n            this.getPoints = arc.getPoints;\r\n            this.getSegments = arc.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = arc.updateMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'Line':\r\n            this.getPoints = line.getPoints;\r\n            this.getSegments = line.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = line.updateMap;\r\n            break;\r\n        case 'Container':\r\n            //container's child\r\n            this.mapChild = (options.mapChild) ? options.mapChild : null;\r\n            //circle segments count\r\n            this.segmentCount = (options.segmentCount) ? options.segmentCount : 0;\r\n            //transformed container's circle children\r\n            this._circles = [];\r\n            this.getPoints = container.getPoints;\r\n            this.getSegments = container.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = container.updateMap;\r\n            this._updateChildMap = container._updateChildMap;\r\n            this.setSegmentCount = segmentCount.setSegmentCount;\r\n            break;\r\n        case 'StaticTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'DynamicTilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'TilemapLayer':\r\n            //ray colliding tiles\r\n            this.collisionTiles = (options.collisionTiles) ? options.collisionTiles : [];\r\n            this.getPoints = tilemap.getPoints;\r\n            this.getSegments = tilemap.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = tilemap.updateMap;\r\n            this.setCollisionTiles = tilemap.setCollisionTiles;\r\n            //reset tilemap origin\r\n            this.object.setOrigin(0,0);\r\n            break;\r\n        case 'MatterBody':\r\n            //force convex body (hull) mapping\r\n            this.forceConvex = (options.forceConvex) ? true : false;\r\n            //force mapping by vertices\r\n            this.forceVerticesMapping = (options.forceVerticesMapping) ? true : false;\r\n            this.circle = false;\r\n            this.getPoints = matterBody.getPoints;\r\n            this.getSegments = matterBody.getSegments;\r\n            this.getBoundingBox = matterBody.getBoundingBox;\r\n            this.updateMap = matterBody.updateMap;\r\n            break;\r\n        default:\r\n            this.getPoints = rectangle.getPoints;\r\n            this.getSegments = rectangle.getSegments;\r\n            this.getBoundingBox = boundingBox.getBoundingBox;\r\n            this.updateMap = rectangle.updateMap;\r\n    }\r\n\r\n    //if object is not supported\r\n    if(this.type != 'MatterBody' && typeof this.object.getBounds !== 'function') {\r\n        this.notSupported = true;\r\n    }\r\n\r\n    //dynamic map\r\n    this.dynamic = (options.dynamic == true) ? true : false;\r\n\r\n    //enable/disable map\r\n    this.active = (options.active !== undefined) ? options.active : true;\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Map#destroy\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    //destroy reference to map object in mapped object\r\n    if(this.object.type === 'body' || this.object.type === 'composite') {\r\n        delete object.raycasterMap;\r\n    }\r\n    else if(this.object.data) {\r\n        this.object.data.remove('raycasterMap');\r\n    }\r\n\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/*Map methods for circles*/\r\n/**\r\n* Get array of mapped circle's vertices used as rays targets.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll calculatoe tangent points for passed ray.\r\n*\r\n* @method Raycaster.Map#arc.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    if(this._points.length > 0)\r\n        return this._points;\r\n    \r\n    let points = [];\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * (this.object.originX - 0.5);\r\n    offset.y = this.object.y - this.object.displayHeight * (this.object.originY - 0.5);\r\n\r\n    //calculate tangent rays\r\n    if(ray) {\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c;\r\n        \r\n        let rotation = this.object.rotation;\r\n        \r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, offset.x, offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            let cB = vector.getPointB();\r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, cB.x, cB.y);\r\n        }\r\n        else { \r\n            c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, offset.x, offset.y);\r\n        }\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(this.object.radius * this.object.scaleX, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((this.object.radius * this.object.scaleX) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped circle's segments used to test object's intersection with ray.\r\n* If {@link Raycaster.Map#segmentCount Raycaster.Map#segmentCount} is set to 0, it'll return empty array.\r\n*\r\n* @method Raycaster.Map#arc.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update circles's map of points and segments.\r\n*\r\n* @method Raycaster.Map#arc.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    if(!this.segmentCount) {\r\n        this._points = [];\r\n        this._segments = [];\r\n        return this;\r\n    }\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX + this.object.radius * this.object.scaleX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY + this.object.radius * this.object.scaleY;\r\n\r\n    //get points surrounding circle\r\n    let points = this.object.geom.getPoints(this.segmentCount);\r\n    let segments = []\r\n\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let newPoints = [];\r\n        for(let point of points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, this.object.x + (point.x + this.object.radius) * this.object.scaleX, this.object.y + (point.y + this.object.radius) * this.object.scaleY);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            newPoints.push(vector.getPointB());\r\n        }\r\n        points = newPoints;\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of points) {\r\n            point.x = point.x * this.object.scaleX + offset.x;\r\n            point.y = point.y * this.object.scaleY + offset.y;\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for containers*/\r\n/**\r\n* Get array of mapped container's and its children vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#container.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n* @param {boolean} [isChild] - Flag definig if it is child container.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false, isChild = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let points = this._points;\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    //get tangent points of container's circles\r\n    if(this.segmentCount == 0 && !isChild) {\r\n        if(ray) {\r\n            //create temporary ray\r\n            let vector = new Phaser.Geom.Line(0, 0, ray.origin.x - offset.x, ray.origin.y - offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, 0, 0, Phaser.Geom.Line.Angle(vector) - this.object.rotation, Phaser.Geom.Line.Length(vector));\r\n    \r\n            let tempRay = ray._raycaster.createRay({\r\n                origin: {\r\n                    x: vector.getPointB().x,\r\n                    y: vector.getPointB().y\r\n                }\r\n            });\r\n\r\n            //calculate tangent rays\r\n            let rayA = new Phaser.Geom.Line();\r\n            let rayB = new Phaser.Geom.Line();\r\n            let c;\r\n\r\n            for(let circle of this._circles) {\r\n                circle.points = [];\r\n                c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, circle.x, circle.y);\r\n\r\n                let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(circle.radius, 2));\r\n\r\n                //ray angle\r\n                let angle = Phaser.Geom.Line.Angle(c);\r\n                let dAngle = Math.asin((circle.radius) / Phaser.Geom.Line.Length(c));\r\n                Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n                Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n                //adding tangent points\r\n                circle.points.push(rayA.getPointB());\r\n                circle.points.push(rayB.getPointB());\r\n                points.push(rayA.getPointB());\r\n                points.push(rayB.getPointB());\r\n            }\r\n        }\r\n    }\r\n    \r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped container's and its children segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#container.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update container's and its children maps of points and segments.\r\n*\r\n* @method Raycaster.Map#container.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.1\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let container = this.object;\r\n    this._circles = [];\r\n\r\n    //calculate offset based on container position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n\r\n    let rotation = container.rotation;\r\n\r\n    if(this.mapChild) {\r\n        this._updateChildMap(this.mapChild, points, segments, rotation, offset);\r\n    }\r\n    else {\r\n        //iterate through container's children\r\n        container.iterate(function(child){\r\n            this._updateChildMap(child, points, segments, rotation, offset);\r\n        }.bind(this));\r\n\r\n        //get children intersections\r\n        for(let i = 0, iLength = container.list.length; i < iLength; i++){\r\n            let childA = container.list[i];\r\n            let mapA = childA.data.get('raycasterMap');\r\n            \r\n            if(!mapA)\r\n                continue;\r\n\r\n            for(let j = i+1, jLength = container.list.length; j < jLength; j++){\r\n                let childB = container.list[j];\r\n                let mapB = childB.data.get('raycasterMap');\r\n                //check if bounding boxes overlap\r\n                if(!mapB || !Phaser.Geom.Intersects.RectangleToRectangle(childA.getBounds(), childB.getBounds()))\r\n                    continue;\r\n\r\n                //find objects intersections\r\n                for(let segmentA of mapA.getSegments()) {\r\n                    for(let segmentB of mapB.getSegments()) {\r\n                        let intersection = [];\r\n                        if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                            continue;\r\n                        \r\n                        //calculate positions after container's rotation\r\n                        if(rotation !== 0) {\r\n                            let vector = new Phaser.Geom.Line(container.x, container.y, intersection.x * container.scaleX + offset.x, intersection.y * container.scaleY + offset.y);\r\n                            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                            points.push(vector.getPointB());\r\n                        }\r\n                        //if rotation === 0\r\n                        else\r\n                            points.push(new Phaser.Geom.Point(intersection.x * container.scaleX + offset.x, intersection.y * container.scaleX + offset.y));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n* Update container's child map of points and segments.\r\n*\r\n* @method Raycaster.Map#container._updateChildMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.10.3\r\n*\r\n* @param {object} [child] - Container's child object.\r\n* @param {Phaser.Geom.Point[]} [points] - Container's mapped points.\r\n* @param {Phaser.Geom.Line[]} [segments] - Container's mapped segments.\r\n* @param {number} [rotation] - Container's rotation.\r\n* @param {Phaser.Geom.Point} [offset] - Container's offset.\r\n*/\r\nexport function _updateChildMap(child, points, segments, rotation, offset) {\r\n    if(!child.data)\r\n        child.setDataEnabled();\r\n\r\n    //if object is not supported\r\n    if(child.data.get('raycasterMapNotSupported'))\r\n        return;\r\n\r\n    //get child map\r\n    let map = child.data.get('raycasterMap');\r\n    if(!map) {\r\n        map = new this.constructor({\r\n            object: child,\r\n            segmentCount: this.segmentCount\r\n        });\r\n\r\n        if(map.notSupported) {\r\n            map.destroy();\r\n            child.data.set('raycasterMapNotSupported', true);\r\n            return;\r\n        }\r\n\r\n        child.data.set('raycasterMap', map);\r\n    }\r\n    else\r\n        map.updateMap();\r\n\r\n    //add child points\r\n    let childPoints = [];\r\n    for(let point of map.getPoints(false, true)) {\r\n        //calculate positions after container's rotation\r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n        //if rotation === 0\r\n        else\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleX + offset.y));\r\n\r\n        childPoints.push(points[points.length - 1])\r\n    }\r\n\r\n    //add child segments\r\n    for(let segment of map.getSegments()) {\r\n        //calculate positions after container's rotation\r\n        if(rotation !== 0) {\r\n            let pointA = segment.getPointA();\r\n            let pointB = segment.getPointB();\r\n            let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n            let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n            Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n\r\n            segments.push(new Phaser.Geom.Line(vectorA.getPointB().x, vectorA.getPointB().y, vectorB.getPointB().x, vectorB.getPointB().y));\r\n        }\r\n        //if rotation === 0\r\n        else\r\n            segments.push(new Phaser.Geom.Line(segment.getPointA().x * this.object.scaleX + offset.x, segment.getPointA().y * this.object.scaleY + offset.y, segment.getPointB().x * this.object.scaleX + offset.x, segment.getPointB().y * this.object.scaleY + offset.y));\r\n    }\r\n\r\n    //if child's map is a circle and this.segmentsCount == 0, store transformed circles in this._circles array.\r\n    if(map.type == 'Arc' && this.segmentCount == 0) {\r\n        let circleOffset = new Phaser.Geom.Point();\r\n        circleOffset.x = (map.object.x - map.object.displayWidth * (map.object.originX - 0.5)) * this.object.scaleX + offset.x;\r\n        circleOffset.y = (map.object.y - map.object.displayHeight * (map.object.originY - 0.5))  * this.object.scaleY + offset.y;\r\n\r\n        if(rotation !== 0) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            circleOffset = vector.getPointB();\r\n        }\r\n\r\n        this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, map.object.radius * map.object.scaleX * this.object.scaleX));\r\n    }\r\n    else if(map.type === 'Container') {\r\n        for(let childMapCircle of map._circles) {\r\n            let circleOffset = new Phaser.Geom.Point();\r\n                circleOffset.x = childMapCircle.x * this.object.scaleX + offset.x;\r\n                circleOffset.y = childMapCircle.y * this.object.scaleY + offset.y;\r\n\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(this.object.x, this.object.y, circleOffset.x, circleOffset.y)\r\n                Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                circleOffset = vector.getPointB();\r\n            }\r\n\r\n            this._circles.push(new Phaser.Geom.Circle(circleOffset.x, circleOffset.y, childMapCircle.radius * this.object.scaleX));\r\n        }\r\n    }\r\n}\r\n","/**\r\n * @classdesc\r\n *\r\n * Map class responsible for mapping game objects.\r\n *\r\n * @namespace Raycaster.Map\r\n * @class Raycaster.Map\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} options - Map specific configuration settings.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Map(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Map#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.9.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Mapped object's type\r\n    *\r\n    * @name Raycaster.Map#type\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.type;\r\n    /**\r\n    * If set true, map will be tested by ray. Otherwise it will be ignored.\r\n    *\r\n    * @name Raycaster.Map#active\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.7.2\r\n    */\r\n    this.active;\r\n    /**\r\n    * If set true, map will be automatically updated on scene update event.\r\n    *\r\n    * @name Raycaster.Map#dynamic\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.6.0\r\n    */\r\n    this.dynamic;\r\n    /**\r\n    * If set true, map will be treated by ray as circle. Set automaticalyy on map update.\r\n    *\r\n    * @name Raycaster.Map#circle\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.9.0\r\n    */\r\n    this.circle = false;\r\n    /**\r\n    * Reference to mapped object.\r\n    *\r\n    * @name Raycaster.Map#object\r\n    * @type {object}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.object;\r\n    /**\r\n    * Array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @name Raycaster.Map#_points\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._points = [];\r\n    /**\r\n    * Array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @name Raycaster.Map#_segments\r\n    * @type {array}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._segments = [];\r\n    /**\r\n    * Get array of mapped object's vertices used as rays targets.\r\n    *\r\n    * @method Raycaster.Map#getPoints\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Point[]} Array of mapped object's vertices.\r\n    */\r\n    this.getPoints;\r\n    /**\r\n    * Get array of mapped object's segments used to test object's intersection with ray.\r\n    *\r\n    * @method Raycaster.Map#getSegments\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {Raycaster.Ray} [ray] - {@link Raycaster.Ray Raycaster.Ray} object used in some some types of maps.\r\n    *\r\n    * @return {Phaser.Geom.Line[]} Array of mapped object's segments.\r\n    */\r\n    this.getSegments;\r\n    /**\r\n    * Get mapped object's bounding box.\r\n    *\r\n    * @method Raycaster.Map#getBoundingBox\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.9.0\r\n    *\r\n    * @return {Phaser.Geom.Rectangle} Mapped object's bounding box.\r\n    */\r\n    this.getBoundingBox;\r\n    /**\r\n    * Update object's map of points and segments.\r\n    *\r\n    * @method Raycaster.Map#updateMap\r\n    * @memberof Raycaster.Map\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n    */\r\n    this.updateMap;\r\n\r\n    this.config(options);\r\n    if(!this.notSupported)\r\n        this.updateMap();\r\n\r\n    return this;\r\n};\r\n\r\nMap.prototype = {\r\n    config: require('./config.js').config,\r\n    destroy: require('./destroy.js').destroy\r\n};\r\n\r\nMap.prototype.constructor = Map;\r\n","/*Map methods for lines*/\r\n/**\r\n* Get array of mapped line's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#line.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped line's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#line.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update line's map of points and segments.\r\n*\r\n* @method Raycaster.Map#line.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    let pointA = this.object.geom.getPointA();\r\n    let pointB = this.object.geom.getPointB();\r\n\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        let vectorA = new Phaser.Geom.Line(this.object.x, this.object.y, pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorA, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorA) + rotation, Phaser.Geom.Line.Length(vectorA));\r\n        pointA = vectorA.getPointB();\r\n\r\n        let vectorB = new Phaser.Geom.Line(this.object.x, this.object.y, pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y);\r\n        Phaser.Geom.Line.SetToAngle(vectorB, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vectorB) + rotation, Phaser.Geom.Line.Length(vectorB));\r\n        pointB = vectorB.getPointB();\r\n\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x, pointA.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x, pointB.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y));\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        //set points\r\n        points.push(new Phaser.Geom.Point(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y));\r\n        points.push(new Phaser.Geom.Point(pointB.x * this.object.scaleX + offset.x, pointB.y * this.object.scaleY + offset.y));\r\n        //set segment\r\n        segments.push(new Phaser.Geom.Line(pointA.x * this.object.scaleX + offset.x, pointA.y * this.object.scaleY + offset.y, pointB.x + offset.x * this.object.scaleX, pointB.y * this.object.scaleY + offset.y));\r\n    }\r\n    \r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n","/*Map methods for matter body*/\r\n/**\r\n* Get array of mapped matter body's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#matterBody.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n\r\n    //calculate tangent rays\r\n    if(ray && !this.forceVerticesMapping && body.circleRadius > 0) {\r\n        let points = [];\r\n        let rayA = new Phaser.Geom.Line();\r\n        let rayB = new Phaser.Geom.Line();\r\n        let c = new Phaser.Geom.Line(ray.origin.x, ray.origin.y, body.position.x, body.position.y);\r\n\r\n        let rayLength = Math.sqrt(Math.pow(Phaser.Geom.Line.Length(c), 2) - Math.pow(body.circleRadius * body.scale.x, 2));\r\n\r\n        //ray angle\r\n        let angle = Phaser.Geom.Line.Angle(c);\r\n        let dAngle = Math.asin((body.circleRadius * body.scale.x) / Phaser.Geom.Line.Length(c));\r\n        Phaser.Geom.Line.SetToAngle(rayA, ray.origin.x, ray.origin.y, angle - dAngle, rayLength);\r\n        Phaser.Geom.Line.SetToAngle(rayB, ray.origin.x, ray.origin.y, angle + dAngle, rayLength);\r\n\r\n        //adding tangent points\r\n        points.push(rayA.getPointB());\r\n        points.push(rayB.getPointB());\r\n\r\n        return points;\r\n    }\r\n\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped matter body's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#matterBody.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update matter body's map of points and segments.\r\n*\r\n* @method Raycaster.Map#matterBody.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    let body = this.object.type === 'body' || this.object.type === 'composite' ? this.object : this.object.body;\r\n    let bodies = [body];\r\n    let generateBounds = false;\r\n\r\n    if(body.circleRadius > 0 && !this.forceVerticesMapping) {\r\n        this.circle = true;\r\n        this._points = points;\r\n        this._segments = segments;\r\n\r\n        return this;\r\n    }\r\n\r\n    this.circle = false;\r\n\r\n    if(body.type == 'composite')\r\n        bodies = body.bodies;\r\n\r\n    if( ( body.bounds === undefined && body.type == 'composite' ) || ( body.type == 'composite' && this.dynamic ) ) {\r\n        generateBounds = true;\r\n    }\r\n    \r\n    for(let bodyItem of bodies) {\r\n        //if convex body\r\n        if(bodyItem.parts.length === 1 || this.forceConvex) {\r\n            let vertices = bodyItem.parts[0].vertices;\r\n\r\n            points.push(new Phaser.Geom.Point(vertices[0].x, vertices[0].y));\r\n\r\n            for(let i = 1, length = vertices.length; i < length; i++) {\r\n                let pointA = new Phaser.Geom.Point(vertices[i - 1].x, vertices[i - 1].y);\r\n                let pointB = new Phaser.Geom.Point(vertices[i].x, vertices[i].y);\r\n\r\n                points.push(pointB);\r\n\r\n                //add segment\r\n                let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n                segments.push(segment);\r\n            }\r\n\r\n            //closing segment\r\n            let segment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\r\n            segments.push(segment);\r\n        }\r\n\r\n        //if concave body\r\n        else if(bodyItem.parts.length > 1) {\r\n            for(let i = 1, length = bodyItem.parts.length; i < length; i++) {\r\n                let vertices = bodyItem.parts[i].vertices;\r\n                let pointA = new Phaser.Geom.Point(vertices[0].x, vertices[0].y);\r\n\r\n                if(points.find(point => point.x == pointA.x && point.y == pointA.y) === undefined)\r\n                    points.push(pointA);\r\n\r\n                for(let j = 1, length = vertices.length; j < length; j++) {\r\n                    let pointB = new Phaser.Geom.Point(vertices[j].x, vertices[j].y);\r\n                    //check if segment was already added\r\n                    let segmentIndex = segments.findIndex(segment => (segment.x1 == pointA.x && segment.y1 == pointA.y && segment.x2 == pointB.x && segment.y2 == pointB.y) || (segment.x1 == pointB.x && segment.y1 == pointB.y && segment.x2 == pointA.x && segment.y2 == pointA.y));\r\n                    \r\n                    if(segmentIndex !== -1) {\r\n                        segments.splice(segmentIndex, 1);\r\n                        pointA = pointB;\r\n                        continue;\r\n                    }\r\n                    \r\n                    if(points.find(point => point.x == pointB.x && point.y == pointB.y) === undefined)\r\n                        points.push(pointB);\r\n\r\n                    //add segment\r\n                    let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n                    segments.push(segment);\r\n                    \r\n                    pointA = pointB;\r\n                }\r\n                \r\n                //closing segment\r\n                let closingSegment = new Phaser.Geom.Line(vertices[vertices.length - 1].x, vertices[vertices.length - 1].y, vertices[0].x, vertices[0].y);\r\n\r\n                let segmentIndex = segments.findIndex(segment => (segment.x1 == closingSegment.x1 && segment.y1 == closingSegment.y1 && segment.x2 == closingSegment.x2 && segment.y2 == closingSegment.y2) || (segment.x1 == closingSegment.x2 && segment.y1 == closingSegment.y2 && segment.x2 == closingSegment.x1 && segment.y2 == closingSegment.y1));\r\n                if(segmentIndex === undefined)\r\n                    segments.push(closingSegment);\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    if(generateBounds) {\r\n        let bounds = this._raycaster.scene.matter.composite.bounds(body);\r\n        body.bounds = bounds;\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n* Get matter body's bounding box.\r\n*\r\n* @method Raycaster.Map#matterBody.getBoundingBox\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.9.0\r\n*\r\n* @return {Phaser.Geom.Rectangle} - Matter body's bounding box.\r\n*/\r\nexport function getBoundingBox() {\r\n    let bounds = this.object.type === 'body' || this.object.type === 'composite' ? this.object.bounds : this.object.body.bounds;\r\n\r\n    return new Phaser.Geom.Rectangle(bounds.min.x, bounds.min.y, bounds.max.x - bounds.min.x, bounds.max.y - bounds.min.y);\r\n}\r\n\r\n","/*Map methods for polygons*/\r\n/**\r\n* Get array of mapped polygon's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#polygon.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped polygon's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#polygon.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update polygon's map of points and segments.\r\n*\r\n* @method Raycaster.Map#polygon.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x - this.object.displayWidth * this.object.originX;\r\n    offset.y = this.object.y - this.object.displayHeight * this.object.originY;\r\n    //set points\r\n    //calculate positions after object's rotation\r\n    let rotation = this.object.rotation;\r\n    if(rotation !== 0) {\r\n        for(let point of this.object.geom.points) {\r\n            let vector = new Phaser.Geom.Line(this.object.x, this.object.y, point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y);\r\n            Phaser.Geom.Line.SetToAngle(vector, this.object.x, this.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n            points.push(vector.getPointB());\r\n        }\r\n    }\r\n    //if rotation === 0\r\n    else {\r\n        for(let point of this.object.geom.points) {\r\n            points.push(new Phaser.Geom.Point(point.x * this.object.scaleX + offset.x, point.y * this.object.scaleY + offset.y));\r\n        }\r\n    }\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n            segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));   \r\n    }\r\n    //if polygon is closed\r\n    if(this.object.closePath) {\r\n        let last = points.length - 1;\r\n        segments.push(new Phaser.Geom.Line(points[last].x, points[last].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for rectangles*/\r\n/**\r\n* Get array of mapped rectangle's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#rectangle.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    return this._points;\r\n};\r\n\r\n/**\r\n* Get array of mapped rectangle's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#rectangle.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments() {\r\n    if(!this.active)\r\n        return [];\r\n    return this._segments;\r\n};\r\n\r\n/**\r\n* Update rectangle's map of points and segments.\r\n*\r\n* @method Raycaster.Map#rectangle.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.6.0\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n        \r\n    let points = [];\r\n    let segments = [];\r\n\r\n    //set points\r\n    points = [\r\n        this.object.getTopLeft(),\r\n        this.object.getTopRight(),\r\n        this.object.getBottomRight(),\r\n        this.object.getBottomLeft()\r\n    ];\r\n\r\n    //set segments\r\n    for(let i = 0, length = points.length; i < length; i++) {\r\n        if(i+1 < length)\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n        else\r\n        segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n\r\n    return this;\r\n};\r\n","/*Map methods for tilemaps*/\r\n/**\r\n* Get array of mapped tilemap's vertices used as rays targets.\r\n*\r\n* @method Raycaster.Map#tilemap.getPoints\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Point[]} - Array of mapped object's vertices.\r\n*/\r\nexport function getPoints(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\r\n        return this._points;\r\n\r\n    let points = [];\r\n    for(let point of this._points) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, point.x, point.y) <= ray.detectionRange)\r\n            points.push(point);\r\n    }\r\n\r\n    //get intersections between tilemap's segments and ray's detection range edge\r\n    let segments = this.getSegments(ray);\r\n\r\n    for(let segment of segments) {\r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x1, segment.y1) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x1, segment.y1));\r\n        \r\n        if(Phaser.Math.Distance.Between(ray.origin.x, ray.origin.y, segment.x2, segment.y2) > ray.detectionRange)\r\n            points.push(new Phaser.Geom.Point(segment.x2, segment.y2));\r\n    }\r\n\r\n    return points;\r\n};\r\n\r\n/**\r\n* Get array of mapped tilemap's segments used to test object's intersection with ray.\r\n*\r\n* @method Raycaster.Map#tilemap.getSegments\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @param {Raycaster.Ray} [ray] - {Raycaster.Ray} object used in some some types of maps.\r\n*\r\n* @return {Phaser.Geom.Line[]} - Array of mapped object's segments.\r\n*/\r\nexport function getSegments(ray = false) {\r\n    if(!this.active)\r\n        return [];\r\n    if(!ray || ray && (ray.detectionRange == 0 || ray.detectionRange >= Phaser.Math.MAX_SAFE_INTEGER))\r\n        return this._segments;\r\n\r\n    let segments = [];\r\n    for(let segment of this._segments) {\r\n        if(Phaser.Geom.Intersects.LineToCircle(segment, ray.detectionRangeCircle)) {\r\n            segments.push(segment);\r\n        }\r\n    }\r\n\r\n    return segments;\r\n};\r\n\r\n/**\r\n* Update tilemap's map of points and segments.\r\n*\r\n* @method Raycaster.Map#tilemap.updateMap\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @private\r\n* @since 0.7.3\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function updateMap() {\r\n    if(!this.active)\r\n        return this;\r\n\r\n    let points = [];\r\n    let segments = [];\r\n    \r\n    //calculate offset based on object position and origin point\r\n    let offset = new Phaser.Geom.Point();\r\n    offset.x = this.object.x;\r\n    offset.y = this.object.y;\r\n\r\n    let horizontal = false;\r\n    let horizontals = [];\r\n    let verticals = [];\r\n\r\n    //iterate rows\r\n    for(let i = 0, iLength = this.object.layer.data.length; i < iLength; i++) {\r\n        let row = this.object.layer.data[i];\r\n\r\n        //iterate row's tiles\r\n        for(let j = 0, jLength = row.length; j < jLength; j++) {\r\n            let tile = row[j];\r\n\r\n            //check if tile and its top and left neighbours have different are from different sets (rays blocking and non-bloking)\r\n            let upperEdge = ((i > 0 && this.collisionTiles.includes(this.object.layer.data[i-1][j].index) != this.collisionTiles.includes(tile.index)) || (i == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\r\n            let leftEdge = ((j > 0 && this.collisionTiles.includes(this.object.layer.data[i][j-1].index) != this.collisionTiles.includes(tile.index)) || (j == 0 && this.collisionTiles.includes(tile.index))) ? true : false;\r\n\r\n            //get current tile's column last vertical line\r\n            let vertical = false;\r\n            if(verticals.length <= j)\r\n                verticals[j] = [];\r\n            else if(verticals[j].length > 0)\r\n                vertical = verticals[j][verticals[j].length - 1];\r\n\r\n            //check if tile has edge from left\r\n            if(leftEdge) {\r\n                if(vertical && vertical.y + vertical.height == i)\r\n                    vertical.height++;\r\n                else {\r\n                    verticals[j].push({\r\n                        x: tile.x,\r\n                        y: tile.y,\r\n                        height: 1\r\n                    });\r\n                }\r\n            }\r\n\r\n            //check if tile has edge from top\r\n            if(upperEdge) {\r\n                if(horizontal)\r\n                    horizontal.width++;\r\n                else\r\n                    horizontal = {\r\n                        x: tile.x,\r\n                        y: tile.y,\r\n                        width: 1\r\n                    };\r\n                continue;\r\n            }\r\n\r\n            if(horizontal) {\r\n                let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n                let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n                let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n                segments.push(segment);\r\n                horizontals.push(segment);\r\n                points.push(new Phaser.Geom.Point(x, y));\r\n                points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n                horizontal = false;\r\n            }\r\n        }\r\n        \r\n        //at the end of row add segment if exist\r\n        if(horizontal) {\r\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n            segments.push(segment);\r\n            horizontals.push(segment);\r\n            points.push(new Phaser.Geom.Point(x, y));\r\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n            horizontal = false;\r\n        }\r\n    }\r\n\r\n    //add bottom horizontal segments\r\n    for(let tile of this.object.layer.data[this.object.layer.data.length - 1]) {\r\n        if(this.collisionTiles.includes(tile.index)) {\r\n            if(horizontal)\r\n                horizontal.width++;\r\n            else\r\n                horizontal = {\r\n                    x: tile.x,\r\n                    y: tile.y + 1,\r\n                    width: 1\r\n                };\r\n            continue;\r\n        }\r\n\r\n        if(horizontal) {\r\n            let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n            let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n            let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n            segments.push(segment);\r\n            horizontals.push(segment);\r\n            points.push(new Phaser.Geom.Point(x, y));\r\n            points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n            horizontal = false;\r\n        }\r\n    }\r\n\r\n    //add segment if exist\r\n    if(horizontal) {\r\n        let x = horizontal.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n        let y = horizontal.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n        let segment = new Phaser.Geom.Line(x, y, x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y);\r\n        segments.push(segment);\r\n        horizontals.push(segment);\r\n        points.push(new Phaser.Geom.Point(x, y));\r\n        points.push(new Phaser.Geom.Point(x + this.object.layer.tileWidth * this.object.scaleX * horizontal.width, y));\r\n        horizontal = false;\r\n    }\r\n    \r\n    //add right vertical segments\r\n    let vertical = false;\r\n    let verticalsLastColumn = [];\r\n    for(let row of this.object.layer.data) {\r\n        let tile = row[row.length - 1];\r\n\r\n        //if tile blocks ray\r\n        if(this.collisionTiles.includes(tile.index)) {\r\n            if(vertical) {\r\n                vertical.height++;\r\n            }\r\n            else {\r\n                vertical = {\r\n                    x: tile.x + 1,\r\n                    y: tile.y,\r\n                    height: 1\r\n                };\r\n            }\r\n\r\n            continue;\r\n        }\r\n\r\n        if(vertical) {\r\n            verticalsLastColumn.push(vertical);\r\n            vertical = false;\r\n        }\r\n    }\r\n\r\n    verticals.push(verticalsLastColumn);\r\n    \r\n    //add vertical segments\r\n    for(let column of verticals) {\r\n        if(!column)\r\n            continue;\r\n\r\n        for(let vertical of column) {\r\n            let x = vertical.x * this.object.layer.tileWidth * this.object.scaleX + offset.x;\r\n            let y1 = vertical.y * this.object.layer.tileHeight * this.object.scaleY + offset.y;\r\n            let y2 = y1 + this.object.layer.tileHeight * this.object.scaleY * vertical.height;\r\n            let segment = new Phaser.Geom.Line(x, y1, x, y2)\r\n            segments.push(segment);\r\n\r\n            //add points if they're not already there\r\n            if(!points.filter(point => point.x == x && point.y == y1))\r\n                points.push(new Phaser.Geom.Point(x, y));\r\n\r\n            if(!points.filter(point => point.x == x && point.y == y2))\r\n                points.push(new Phaser.Geom.Point(x, y));\r\n\r\n            //get intersections between horizontal segments and vertical\r\n            for(let horizontalSegment of horizontals) {\r\n                if(segment.x1 == horizontalSegment.x1 || segment.x1 == horizontalSegment.x2 || segment.x2 == horizontalSegment.x1 || segment.x2 == horizontalSegment.x2)\r\n                    continue;\r\n\r\n                if(segment.y1 == horizontalSegment.y1 || segment.y1 == horizontalSegment.y2 || segment.y2 == horizontalSegment.y1 || segment.y2 == horizontalSegment.y2)\r\n                    continue;\r\n\r\n                let point = new Phaser.Geom.Point();\r\n                if(Phaser.Geom.Intersects.LineToLine(segment, horizontalSegment, point)) {\r\n                    points.push(point);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    this._points = points;\r\n    this._segments = segments;\r\n    return this;\r\n};\r\n\r\n/**\r\n* Set tile types which should be mapped (for Phaser.Tilemaps.StaticTilemapLayer and Phaser.Tilemaps.DynamicTilemapLayer maps only).\r\n*\r\n* @method Raycaster.Map#setCollisionTiles\r\n* @memberof Raycaster.Map\r\n* @instance\r\n* @since 0.7.3\r\n*\r\n* @param {array} [tiles = []] - Set of tile's indexes to map.\r\n*\r\n* @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n*/\r\nexport function setCollisionTiles(tiles = []) {\r\n    this.collisionTiles = tiles;\r\n    return this;\r\n}\r\n","/**\r\n * Set segment count for cirle's map.\r\n * If set to 0, map won't be generating segments and relay only on tangent points calculated for currently testing ray.\r\n *\r\n * @method Raycaster.Map#setSegmentCount\r\n * @memberof Raycaster.Map\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} count - Circle map's segment count.\r\n *\r\n * @return {Raycaster.Map} {@link Raycaster.Map Raycaster.Map} instance\r\n */\r\nexport function setSegmentCount(count) {\r\n    this.segmentCount = count;\r\n    this.circle = count ? false : true;\r\n\r\n    this.updateMap();\r\n    return this;\r\n}\r\n","/**\r\n * Set ray's angle (direction) in radians.\r\n *\r\n * @method Raycaster.Ray#setAngle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [angle = 0] - Ray's angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngle(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's angle (direction) in degrees.\r\n *\r\n * @method Raycaster.Ray#setAngleDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.1\r\n *\r\n * @param {number} [angle = 0] - Ray's angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setAngleDeg(angle = 0) {\r\n    this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(angle));\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n","/**\r\n * Cast ray to find closest intersection with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#cast\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = {Raycaster#mappedObjects}] - Array of game objects to test. If not provided test all mapped game objects.\r\n * @param {Phaser.Geom.Point|Point} [options.target] - Ray's target point. Used in other casting methods to determine if ray was targeting mapped objects point.\r\n * @param {boolean} [options.internal = false] - Flag determining if method is used by other casting method.\r\n *\r\n * @return {(Phaser.Geom.Point|boolean)} Ray's closest intersection with tested objects. Returns false if no intersection has been found. Additionally contains reference to hit mapped object and segment if available.\r\n */\r\nexport function cast(options = {}) {\r\n    let closestIntersection;\r\n    let closestSegment;\r\n    let closestObject;\r\n    let closestDistance = this.rayRange;\r\n    let internal = options.internal ? options.internal : false;\r\n    let startTime = performance.now();\r\n    let stats = {\r\n        method: 'cast',\r\n        rays: 1,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //if bounding box is defined check bounding box intersection\r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        let intersections = [];\r\n        Phaser.Geom.Intersects.GetLineToRectangle(this._ray, this._raycaster.boundingBox.rectangle, intersections);\r\n        if(intersections.length === 1)\r\n            closestIntersection = intersections[0];\r\n        else if(intersections.length > 1) {\r\n            for(let intersection of intersections) {\r\n                let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                if(distance < closestDistance) {\r\n                    closestDistance = distance;\r\n                    closestIntersection = intersection;\r\n                }\r\n            }\r\n        }\r\n        //if ray target is declared\r\n        else if(options.target){\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, options.target.x, options.target.y);\r\n            //if target is within ray range\r\n            if(this.rayRange > distance) {\r\n                closestDistance = distance;\r\n                closestIntersection = options.target;\r\n            }\r\n        }\r\n    }\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n    \r\n    for(let object of options.objects) {\r\n        let map, boundingBox;\r\n        \r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        stats.testedMappedObjects++;\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        if(internal) {\r\n            boundingBox = map._boundingBox;\r\n        }\r\n        else {\r\n            boundingBox = map.getBoundingBox();\r\n            boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n        }\r\n\r\n        //check if object is intersected by ray\r\n        if(Phaser.Geom.Intersects.GetLineToRectangle(this._ray, boundingBox).length === 0)\r\n            continue;\r\n\r\n        stats.hitMappedObjects++;\r\n        stats.segments += map.getSegments(this).length;\r\n        \r\n        //check intersections\r\n        for(let segment of map.getSegments(this)) {\r\n            let intersection = [];\r\n\r\n            //if target point is segmemt point\r\n            if(options.target) {\r\n                if(\r\n                    Phaser.Geom.Point.Equals(options.target, segment.getPointA())\r\n                    || Phaser.Geom.Point.Equals(options.target, segment.getPointB())\r\n                ) {\r\n                    intersection = options.target;\r\n                }\r\n                else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n                    continue;\r\n            }\r\n            //if no intersection continue\r\n            else if(!Phaser.Geom.Intersects.LineToLine(this._ray, segment, intersection))\r\n              continue;\r\n            \r\n            //get closest intersection\r\n            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n            if(distance < closestDistance) {\r\n                closestDistance = distance;\r\n                closestIntersection = intersection;\r\n                closestObject = map.object;\r\n                closestSegment = segment;\r\n            }\r\n        }\r\n\r\n        //check if map is circular\r\n        if(map.circle) {\r\n           //if circular map has generated points (besides tangent points to ray)\r\n            if(map._points.length > 0) {\r\n                continue;\r\n            }\r\n            \r\n            //check if target point is a circle tangent point to ray\r\n            if(options.target) {\r\n                let points = map.getPoints(this);\r\n                let isTangent = false;\r\n                for(let point of points) {\r\n                    if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = point;\r\n                            closestObject = map.object;\r\n                            isTangent = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n\r\n                if(isTangent)\r\n                    continue;\r\n            }\r\n\r\n            let circleIntersections = [];\r\n            let offset = new Phaser.Geom.Point();\r\n            offset.x = map.object.x - map.object.displayWidth * (map.object.originX - 0.5);\r\n            offset.y = map.object.y - map.object.displayHeight * (map.object.originY - 0.5);\r\n\r\n            //calculate circle's center after rotation\r\n            let rotation = map.object.rotation;\r\n            if(rotation !== 0) {\r\n                let vector = new Phaser.Geom.Line(map.object.x, map.object.y, offset.x, offset.y);\r\n                Phaser.Geom.Line.SetToAngle(vector, map.object.x, map.object.y, Phaser.Geom.Line.Angle(vector) + rotation, Phaser.Geom.Line.Length(vector));\r\n                let cB = vector.getPointB();\r\n                offset.x = cB.x;\r\n                offset.y = cB.y;\r\n            }\r\n\r\n            //create transformed circle\r\n            let circle = new Phaser.Geom.Circle(offset.x, offset.y, map.object.radius * map.object.scaleX);\r\n\r\n            if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                for(let intersection of circleIntersections) {\r\n                    //get closest intersection\r\n                    let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                    if(distance < closestDistance) {\r\n\r\n                        closestDistance = distance;\r\n                        closestIntersection = intersection;\r\n                        closestObject = map.object;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        //check container map's circles\r\n        if(map.type == 'Container' && map._circles.length > 0) {\r\n            for(let circle of map._circles) {\r\n                //check if target point is a circle tangent point to ray\r\n                if(options.target) {\r\n                    let isTangent = false;\r\n\r\n                    for(let point of circle.points) {\r\n                        if(Phaser.Geom.Point.Equals(options.target, point)) {\r\n                            //get closest intersection\r\n                            let distance = Phaser.Math.Distance.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n\r\n                            if(distance < closestDistance) {\r\n                                closestDistance = distance;\r\n                                closestIntersection = point;\r\n                                closestObject = map.object;\r\n                                isTangent = true;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n\r\n                    if(isTangent)\r\n                        continue;\r\n                }\r\n\r\n                let circleIntersections = [];\r\n\r\n                if(Phaser.Geom.Intersects.GetLineToCircle(this._ray, circle, circleIntersections)) {\r\n                    for(let intersection of circleIntersections) {\r\n                        //get closest intersection\r\n                        let distance = Phaser.Math.Distance.Between(this._ray.x1, this._ray.y1, intersection.x, intersection.y);\r\n\r\n                        if(distance < closestDistance) {\r\n                            closestDistance = distance;\r\n                            closestIntersection = intersection;\r\n                            closestObject = map.object;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //update stats\r\n    if(internal) {\r\n        this._stats.rays++;\r\n        this._stats.testedMappedObjects += stats.testedMappedObjects;\r\n        this._stats.hitMappedObjects += stats.hitMappedObjects;\r\n        this._stats.segments += stats.segments;\r\n    }\r\n    else {\r\n        stats.time = performance.now() - startTime;\r\n        this._stats = stats;\r\n    }\r\n\r\n    let result;\r\n    if(!closestIntersection) {\r\n        if(this.ignoreNotIntersectedRays)\r\n            return false;\r\n\r\n        result = this._ray.getPointB();\r\n    }\r\n    else {\r\n        result = new Phaser.Geom.Point(closestIntersection.x, closestIntersection.y);\r\n        result.segment = closestSegment;\r\n        result.object = closestObject;\r\n    }\r\n\r\n    if(this.round) {\r\n        result.x = Math.round(result.x);\r\n        result.y = Math.round(result.y);\r\n    }\r\n\r\n    if(!internal)\r\n        this.drawDebug([result]);\r\n    \r\n    return result;\r\n}","/**\r\n * Cast ray in all directions to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCircle\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\r\n */\r\nexport function castCircle(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let startTime = performance.now();\r\n    //reset stats\r\n    this._stats = {\r\n        method: 'castCircle',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n\r\n    //if bounding box is defined add bounding box points to \r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        for(let point of this._raycaster.boundingBox.points) {\r\n            rayTargets.push({\r\n                point: point,\r\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n            });\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map, boundingBox;\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        boundingBox = map.getBoundingBox();\r\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n\r\n        map._boundingBox = boundingBox;\r\n\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n            rayTargets.push({\r\n                point: point,\r\n                angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y)\r\n            });\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB;\r\n            if(objectB.type === 'body' || objectB.type === 'composite')\r\n                mapB = objectB.raycasterMap;\r\n            else {\r\n                mapB = objectB.data.get('raycasterMap');\r\n            }\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    \r\n                    rayTargets.push({\r\n                        point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                        angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y)\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angle - b.angle;\r\n    }.bind(this));\r\n\r\n    let previousTarget = {\r\n        angle: false\r\n    };\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        //if current target is the same as previous one skip loop\r\n        if(target.angle === previousTarget.angle) {\r\n            continue;\r\n        }\r\n\r\n        previousTarget = target;\r\n\r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point,\r\n            internal: true\r\n        });\r\n\r\n        if(intersection){\r\n            //if intersection hits target point cast two additional rays\r\n            let castSides = false;\r\n            if(this.round) {\r\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n            }\r\n            else {\r\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n            }\r\n            \r\n            if(castSides) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionA) {\r\n                    intersections.push(intersectionA);\r\n                }\r\n\r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionB) {\r\n                    intersections.push(intersectionB);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice();\r\n\r\n    this._stats.time = performance.now() - startTime;\r\n\r\n    this.drawDebug(intersections);\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Cast ray in a cone to find closest intersections with tested mapped objects.\r\n *\r\n * @method Raycaster.Ray#castCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {object} [options] - options that may include:\r\n * @param {object[]} [options.objects = Raycaster.mappedObjects] - Array of game objects to test. If not provided test all mapped game objects.\r\n *\r\n * @return {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects. Additionally each point contains reference to hit mapped object and it's segment if available.\r\n */\r\nexport function castCone(options = {}) {\r\n    let originalAngle = this.angle;\r\n    let intersections = [];\r\n    let maps = [];\r\n    let rayTargets = [];\r\n    let testedObjects = [];\r\n    let cone = this.cone;\r\n    let minAngle = 0;\r\n    let maxAngle = 0;\r\n    let angleOffset = 0;\r\n    let startTime = performance.now();\r\n    //reset stats\r\n    this._stats = {\r\n        method: 'castCone',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    //set cone\r\n    if(options.cone !== undefined)\r\n        cone = options.cone;\r\n    if(options.coneDeg !== undefined)\r\n        cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //set cone min and max angle\r\n    minAngle = this.angle - cone / 2;\r\n    maxAngle = this.angle + cone / 2;\r\n\r\n    //add min and max angle points\r\n    this.setAngle(minAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: minAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(-cone / 2)\r\n    });\r\n\r\n    this.setAngle(maxAngle);\r\n    rayTargets.push({\r\n        point: this._ray.getPointB(),\r\n        angle: maxAngle,\r\n        angleOffsetDeg: Phaser.Math.RadToDeg(cone / 2)\r\n    });\r\n\r\n    //if no objects to cast ray were passed, use raycasters mapped objects\r\n    if(!options.objects) {\r\n        if(this._raycaster)\r\n            options.objects = this._raycaster.mappedObjects;\r\n        else\r\n            return intersections;\r\n    }\r\n\r\n    //if bounding box is defined add bounding box points to \r\n    if(this._raycaster && this._raycaster.boundingBox) {\r\n        for(let point of this._raycaster.boundingBox.points) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: angle,\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n    }\r\n\r\n    for(let i=0, iLength = options.objects.length; i < iLength; i++) {\r\n        let object = options.objects[i];\r\n        //if bound in range\r\n        if(!this.boundsInRange(object))\r\n            continue;\r\n        \r\n        testedObjects.push(object);\r\n\r\n        let map, boundingBox;\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            map = object.raycasterMap;\r\n        else\r\n            map = object.data.get('raycasterMap');\r\n\r\n        //get slightly enlarged bounding box due to fridge cases, when ray \"glanced\" border box's corner (v0.10.1)\r\n        boundingBox = map.getBoundingBox();\r\n        boundingBox.setTo(boundingBox.x - 0.1, boundingBox.y - 0.1, boundingBox.width + 0.2, boundingBox.height + 0.2);\r\n\r\n        map._boundingBox = boundingBox;\r\n\r\n        maps.push(map);\r\n        //get points and angles\r\n        for(let point of map.getPoints(this)) {\r\n\r\n            let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y);\r\n            let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n            if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                rayTargets.push({\r\n                    point: point,\r\n                    angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, point.x, point.y),\r\n                    angleOffsetDeg: -angleOffsetDeg\r\n                });\r\n            }\r\n        }\r\n\r\n        //get objects intersections\r\n        for(let j = i+1, jLength = options.objects.length; j < jLength; j++){\r\n            let objectB = options.objects[j];\r\n            let mapB;\r\n            if(objectB.type === 'body' || objectB.type === 'composite')\r\n                mapB = objectB.raycasterMap;\r\n            else\r\n                mapB = objectB.data.get('raycasterMap');\r\n            //check if bounding boxes overlap\r\n            if(!Phaser.Geom.Intersects.RectangleToRectangle(map.getBoundingBox(), mapB.getBoundingBox()))\r\n                continue;\r\n            \r\n            //find objects intersections\r\n            for(let segmentA of map.getSegments(this)) {\r\n                for(let segmentB of mapB.getSegments(this)) {\r\n                    let intersection = [];\r\n                    if(!Phaser.Geom.Intersects.LineToLine(segmentA, segmentB, intersection))\r\n                        continue;\r\n                    let angle = Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y);\r\n                    let angleOffsetDeg = Phaser.Math.Angle.ShortestBetween(Phaser.Math.RadToDeg(angle), Phaser.Math.RadToDeg(originalAngle));\r\n\r\n                    if(Math.abs(angleOffsetDeg) < Phaser.Math.RadToDeg(cone / 2)) {\r\n                        rayTargets.push({\r\n                            point: new Phaser.Geom.Point(intersection.x, intersection.y),\r\n                            angle: Phaser.Math.Angle.Between(this.origin.x, this.origin.y, intersection.x, intersection.y),\r\n                            angleOffsetDeg: -angleOffsetDeg\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //sort target points by angle\r\n    rayTargets.sort(function(a, b){\r\n        //if rays towards points have the same angles promote closer one\r\n        if(a.angle == b.angle) {\r\n            if(Phaser.Math.Distance.Between(this.origin.x, this.origin.y, a.point.x, a.point.y) > Phaser.Math.Distance.Between(this.origin.x, this.origin.y, b.point.x, b.point.y))\r\n                return 1;\r\n            else\r\n                return -1;\r\n        }\r\n\r\n        return a.angleOffsetDeg - b.angleOffsetDeg;\r\n    }.bind(this));\r\n\r\n    let previousTarget = {\r\n        angle: false\r\n    };\r\n\r\n    //cast rays\r\n    for(let target of rayTargets){\r\n        //if current target is the same as previous one skip loop\r\n        if(target.angle === previousTarget.angle) {\r\n            continue;\r\n        }\r\n\r\n        previousTarget = target;\r\n        \r\n        this.setAngle(target.angle);\r\n        let intersection = this.cast({\r\n            objects: testedObjects,\r\n            target: target.point,\r\n            internal: true\r\n        });\r\n        if(intersection){\r\n            //if intersection hits target point cast two additional rays\r\n            let castSides = false;\r\n            if(this.round) {\r\n                let roundedTarget = new Phaser.Geom.Point(Math.round(target.point.x), Math.round(target.point.y));\r\n                castSides = Phaser.Geom.Point.Equals(roundedTarget, intersection)\r\n            }\r\n            else {\r\n                castSides = Phaser.Geom.Point.Equals(target.point, intersection);\r\n            }\r\n            if(castSides) {\r\n                this.setAngle(target.angle - 0.0001);\r\n                let intersectionA = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionA) {\r\n                    intersections.push(intersectionA);\r\n                }\r\n\r\n                intersections.push(intersection);\r\n\r\n                this.setAngle(target.angle + 0.0001);\r\n                let intersectionB = this.cast({\r\n                    objects: testedObjects,\r\n                    internal: true\r\n                });\r\n\r\n                if(intersectionB) {\r\n                    intersections.push(intersectionB);\r\n                }\r\n\r\n                continue;\r\n            }\r\n\r\n            intersections.push(intersection);\r\n        }\r\n    }\r\n\r\n    this.setAngle(originalAngle);\r\n    this.intersections = intersections;\r\n    if(this.autoSlice)\r\n        this.slicedIntersections = this.slice(intersections, false);\r\n    \r\n    this._stats.time = performance.now() - startTime;\r\n\r\n    this.drawDebug(intersections);\r\n\r\n    return intersections;\r\n}\r\n","/**\r\n * Set ray's cone angle (width) in radians.\r\n *\r\n * @method Raycaster.Ray#setCone\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {number} [cone = 0] - Ray's cone angle in radians.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCone(cone = 0) {\r\n    this.cone = cone;\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's cone angle (width) in degrees.\r\n *\r\n * @method Raycaster.Ray#setConeDeg\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.7.0\r\n *\r\n * @param {number} [cone = 0] - Ray's cone angle in degrees.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setConeDeg(cone = 0) {\r\n    this.cone = Phaser.Math.DegToRad(cone);\r\n    return this;\r\n}\r\n","/**\r\n * Configure ray.\r\n *\r\n * @method Raycaster.Ray#config\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function config(options) {\r\n    this.object = options.object;\r\n    //origin\r\n    if(options.origin !== undefined)\r\n        this.origin.setTo(options.origin.x, options.origin.y);\r\n\r\n    //angle\r\n    if(options.angle !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(options.angle);\r\n\r\n    //angle deg\r\n    if(options.angleDeg !== undefined)\r\n        this.angle = Phaser.Math.Angle.Normalize(Phaser.Math.DegToRad(options.angleDeg));\r\n\r\n    //cone angle\r\n    if(options.cone !== undefined)\r\n        this.cone = options.cone;\r\n\r\n    //cone angle deg\r\n    if(options.coneDeg !== undefined)\r\n        this.cone = Phaser.Math.DegToRad(options.coneDeg);\r\n\r\n    //ray range (0 = max)\r\n    if(options.rayRange !== undefined)\r\n        this.rayRange = options.rayRange;\r\n\r\n    //collision range (0 = max)\r\n    if(options.collisionRange !== undefined)\r\n        this.collisionRange = options.collisionRange;\r\n\r\n    //detection range (0 = max)\r\n    if(options.detectionRange !== undefined)\r\n        this.detectionRange = options.detectionRange;\r\n\r\n    //ignore not intersected rays\r\n    if(options.ignoreNotIntersectedRays !== undefined)\r\n        this.ignoreNotIntersectedRays = (options.ignoreNotIntersectedRays == true)\r\n    \r\n    //round\r\n    if(options.round !== undefined)\r\n        this.round = (options.round == true)\r\n\r\n    //auto slice\r\n    if(options.autoSlice !== undefined)\r\n        this.autoSlice = (options.autoSlice == true)\r\n\r\n    //enable physics\r\n    if(options.enablePhysics !== undefined && options.enablePhysics)\r\n        this.enablePhysics(options.enablePhysics);\r\n    \r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this._raycaster.debugOptions.enabled && this._raycaster.scene !== undefined) {\r\n        this.graphics =  this._raycaster.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n        this.graphics.setDepth(1000);\r\n    }\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Draw rays in debug mode\r\n *\r\n * @method Raycaster.Ray#drawDebug\r\n * @memberof Raycaster\r\n * @private\r\n * @since 0.10\r\n * \r\n * @param {Phaser.Geom.Point[]} Array of points of ray's closest intersections with tested objects.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function drawDebug(intersections) {\r\n    if(this.graphics === undefined || !this._raycaster.debugOptions.enabled)\r\n        return this;\r\n\r\n    //clear\r\n    this.graphics.clear();\r\n\r\n    if(!this._raycaster.debugOptions.rays)\r\n        return this;\r\n    \r\n    if(this._raycaster.debugOptions.graphics.ray) {\r\n        this.graphics.lineStyle(1, this._raycaster.debugOptions.graphics.ray);\r\n\r\n        for(let intersection of intersections) {\r\n            this.graphics.strokeLineShape({\r\n                x1: this.origin.x,\r\n                y1: this.origin.y,\r\n                x2: intersection.x,\r\n                y2: intersection.y\r\n            });\r\n        }\r\n    }\r\n\r\n    if(this._raycaster.debugOptions.graphics.rayPoint) {\r\n        this.graphics.fillStyle(this._raycaster.debugOptions.graphics.rayPoint);\r\n\r\n        this.graphics.fillPoint(this.origin.x, this.origin.y, 3);\r\n        \r\n        for(let intersection of intersections) {\r\n            this.graphics.fillPoint(intersection.x, intersection.y, 3);\r\n        }\r\n    }\r\n\r\n    return this;\r\n}","/**\r\n * Destroy object\r\n *\r\n * @method Raycaster.Ray#destroy\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.3\r\n */\r\n export function destroy() {\r\n    for(let key in this) {\r\n        delete this[key];\r\n    }\r\n }","/**\r\n * Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. Physics body can be added only once.\r\n *\r\n * @method Raycaster.Ray#enablePhysics\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {'arcade'|'matter'} [type = 'arcade'] - Physics type\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function enablePhysics(type = 'arcade') {\r\n    \r\n    if(this.body !== undefined)\r\n        return this;\r\n\r\n    this.collisionCircle = this._raycaster.scene.add.circle(this.origin.x, this.origin.y, this.collisionRange);\r\n    this.collisionCircle._ray = this;\r\n\r\n    if(type === 'matter') {\r\n        this.bodyType = 'matter';\r\n\r\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\r\n            let bounds = this._raycaster.boundingBox;\r\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'rectangle', x:bounds.rectangle.centerX, y:bounds.rectangle.centerY, width:bounds.rectangle.width, height:bounds.rectangle.height }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\r\n        }\r\n        else {\r\n            this._raycaster.scene.matter.add.gameObject(this.collisionCircle, { shape: { type: 'circle' }, label: 'phaser-raycaster-ray-body', isSensor: true, ignoreGravity:true });\r\n        }\r\n\r\n        this.body = this.collisionCircle.body;\r\n        this.body._ray = this;\r\n        this.setOnCollideActive();\r\n    }\r\n    else {\r\n        this.bodyType = 'arcade';\r\n        this._raycaster.scene.physics.add.existing(this.collisionCircle);\r\n\r\n        this.body = this.collisionCircle.body;\r\n        this.body\r\n            .setCircle(this.collisionRange)\r\n            .setAllowGravity(false)\r\n            .setImmovable(true);\r\n        this.body._ray = this;\r\n    }\r\n\r\n    return this;\r\n}\r\n","/*Matter physics methods for ray body*/\r\n/**\r\n * Sets the collision category of this ray's Matter Body. This number must be a power of two between 2^0 (= 1) and 2^31.\r\n * Two bodies with different collision groups (see {@link #setCollisionGroup}) will only collide if their collision\r\n * categories are included in their collision masks (see {@link #setCollidesWith}).\r\n *\r\n * @method Raycaster.Ray#setCollisionCategory\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {number} value - Unique category bitfield.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionCategory(value) {\r\n    this.body.collisionFilter.category = value;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the collision group of this ray's Matter Body. If this is zero or two Matter Bodies have different values,\r\n * they will collide according to the usual rules (see {@link #setCollisionCategory} and {@link #setCollisionGroup}).\r\n * If two Matter Bodies have the same positive value, they will always collide; if they have the same negative value,\r\n * they will never collide.\r\n *\r\n * @method Raycaster.Ray#setCollisionCategory\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {number} value - Unique group index.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionGroup(value) {\r\n    this.body.collisionFilter.group = value;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * Sets the collision mask for this ray's Matter Body. Two Matter Bodies with different collision groups will only\r\n * collide if each one includes the other's category in its mask based on a bitwise AND, i.e. `(categoryA & maskB) !== 0`\r\n * and `(categoryB & maskA) !== 0` are both true.*\r\n *\r\n * @method Raycaster.Ray#setCollidesWith\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {(number|number[])} categories - A unique category bitfield, or an array of them.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\n\r\nexport function setCollidesWith(categories) {\r\n    var flags = 0;\r\n\r\n    if (!Array.isArray(categories))\r\n    {\r\n        flags = categories;\r\n    }\r\n    else\r\n    {\r\n        for (var i = 0; i < categories.length; i++)\r\n        {\r\n            flags |= categories[i];\r\n        }\r\n    }\r\n\r\n    this.body.collisionFilter.mask = flags;\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollide\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke when this body starts colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollide(callback) {\r\n    let self = this;\r\n    this.body.onCollideCallback = function(collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            callback(collisionInfo);\r\n        }\r\n        else if(self.processOverlap(collisionInfo)) {\r\n            collisionInfo.rayCollided = true;\r\n            callback(collisionInfo);\r\n        }\r\n    };\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideEnd\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke when this body stops colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideEnd(callback) {\r\n    this.body.onCollideEndCallback = function(collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            collisionInfo.rayCollided = false;\r\n            callback(collisionInfo);\r\n        }\r\n    }\r\n\r\n    return this;\r\n};\r\n\r\n/**\r\n * The callback is sent a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideActive\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {function} callback - The callback to invoke for the duration of this body colliding with another.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideActive(callback) {\r\n    let self = this;\r\n    let func = function(collisionInfo) {\r\n        if(self.processOverlap(collisionInfo)) {\r\n            let body = collisionInfo.bodyA.label === 'phaser-raycaster-ray-body' ? collisionInfo.bodyB : collisionInfo.bodyA;\r\n\r\n            if(collisionInfo.rayCollided !== true) {\r\n                collisionInfo.rayCollided = true;\r\n                if(self.body.onCollideCallback) {\r\n                    self.body.onCollideCallback(collisionInfo);\r\n                }\r\n\r\n                if(self.body.onCollideWith !== undefined && self.body.onCollideWith[body.id]) {\r\n                    self.body.onCollideWith[body.id](body, collisionInfo);\r\n                }\r\n            }\r\n            if(callback)\r\n                callback(collisionInfo);\r\n        }\r\n        else {\r\n            if(self.body.onCollideEndCallback && collisionInfo.rayCollided === true) {\r\n                self.body.onCollideEndCallback(collisionInfo);\r\n            }\r\n        }\r\n    }\r\n\r\n    this.body.onCollideActiveCallback = func;\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * The callback is sent a reference to the other body, along with a `Phaser.Types.Physics.Matter.MatterCollisionData` object.\r\n * \r\n * This does not change the bodies collision category, group or filter. Those must be set in addition\r\n * to the callback.\r\n *\r\n * @method Raycaster.Ray#setOnCollideWith\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.9.1\r\n *\r\n * @param {(MatterJS.Body|MatterJS.Body[])} body - The body, or an array of bodies, to test for collisions with.\r\n * @param {function} callback - The callback to invoke when this body collides with the given body or bodies.\r\n * \r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOnCollideWith(body, callback) {\r\n    let self = this;\r\n    let func = function(body, collisionInfo) {\r\n        if(collisionInfo.rayCollided) {\r\n            callback(body, collisionInfo);\r\n        }\r\n        else if(self.processOverlap(collisionInfo)) {\r\n            collisionInfo.rayCollided = true;\r\n            callback(body, collisionInfo);\r\n        }\r\n    }\r\n\r\n    if (!Array.isArray(body))\r\n    {\r\n        body = [ body ];\r\n    }\r\n\r\n    for (var i = 0; i < body.length; i++)\r\n    {\r\n        var src = (body[i].hasOwnProperty('body')) ? body[i].body : body[i];\r\n\r\n        this.body.setOnCollideWith(src, func);\r\n    }\r\n\r\n    return this;\r\n};\r\n","/**\r\n * Set ray's source position.\r\n *\r\n * @method Raycaster.Ray#setOrigin\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setOrigin(x, y) {\r\n    this.origin.setTo(x, y);\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    if(this.bodyType === 'matter' && this.collisionRange !== Phaser.Math.MAX_SAFE_INTEGER) {\r\n        this.collisionCircle.x = x;\r\n        this.collisionCircle.y = y;\r\n    }\r\n    else if(this.bodyType === 'arcade') {\r\n        this.collisionCircle.x = x;\r\n        this.collisionCircle.y = y;\r\n    }\r\n\r\n    return this;\r\n}\r\n","/**\r\n * Get game objects overlaping field of view.\r\n *\r\n * @method Raycaster.Ray#overlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object|object[]} [objects] - Game object / array off game objects to test.\r\n *\r\n * @return {object[]} Array of game objects that overlaps with field of view.\r\n */\r\nexport function overlap(objects) {\r\n    let targets = [];\r\n    let overlapCircle = new Phaser.Geom.Circle(this.origin.x, this.origin.y, this.collisionRange);\r\n\r\n    //matter physics\r\n    if(this.bodyType === 'matter') {\r\n        let isCollisionInfo = false;\r\n        if(objects === undefined) {\r\n            objects = this._raycaster.scene.matter.query.collides(this.body, this._raycaster.scene.matter.getMatterBodies());\r\n\r\n            for(let object of objects) {   \r\n                let body = object.bodyA === this.body ? object.bodyB : object.bodyA;\r\n\r\n                if(this.testMatterOverlap(body))\r\n                    targets.push(body);\r\n            }\r\n        }\r\n        //get object's body\r\n        else {\r\n            if(!Array.isArray(objects))\r\n                objects = [objects];\r\n            \r\n            for(let object of objects) {\r\n                if(object === this.body)\r\n                    continue;\r\n    \r\n                if(this.testMatterOverlap(object))\r\n                    targets.push(object);\r\n            }\r\n        }\r\n    }\r\n    //arcade physics\r\n    else {\r\n        let bodies = false;\r\n        //get bodies in range\r\n        if(objects === undefined) {\r\n            objects = this._raycaster.scene.physics.overlapCirc(this.origin.x, this.origin.y, this.collisionRange, true, true);\r\n            bodies = true;\r\n        }\r\n        //get object's body\r\n        else if(!Array.isArray(objects)) {\r\n            objects = [objects];\r\n        }\r\n        //if objects are bodies\r\n        if(bodies) {\r\n            for(let body of objects) {\r\n                if(body === this.body)\r\n                    continue;\r\n            \r\n                let hitbox;\r\n                //get physics body hitbox\r\n                if(body.isCircle) {\r\n                    hitbox = new Phaser.Geom.Circle(body.position.x + body.halfWidth, body.position.y + body.halfWidth, body.halfWidth);\r\n                }\r\n                else {\r\n                    hitbox = new Phaser.Geom.Rectangle(body.x, body.y, body.width, body.height);\r\n                }\r\n\r\n                if(this.testArcadeOverlap(hitbox))\r\n                    targets.push(body.gameObject);\r\n            }\r\n        }\r\n        //if objects are game objects\r\n        else {\r\n            for(let object of objects) {\r\n                if(object.body === undefined)\r\n                    continue;\r\n\r\n                let hitbox;\r\n                //get physics body hitbox\r\n                if(object.body.isCircle) {\r\n                    hitbox = new Phaser.Geom.Circle(object.body.position.x + object.body.halfWidth, object.body.position.y + object.body.halfWidth, object.body.halfWidth);\r\n                    if(!Phaser.Geom.Intersects.CircleToCircle(overlapCircle, hitbox))\r\n                        continue;\r\n                }\r\n                else {\r\n                    hitbox = new Phaser.Geom.Rectangle(object.body.x, object.body.y, object.body.width, object.body.height);\r\n                    if(!Phaser.Geom.Intersects.CircleToRectangle(overlapCircle, hitbox))\r\n                        continue;\r\n                }\r\n\r\n                if(this.testArcadeOverlap(hitbox))\r\n                    targets.push(object);\r\n            }\r\n        }\r\n    }\r\n\r\n    return targets;\r\n}\r\n\r\n/**\r\n * Process callback for physics collider / overlap.\r\n *\r\n * @method Raycaster.Ray#processOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {object} object1 - Game object or matter body passed by collider / overlap or matter CollisionInfo object.\r\n * @param {object} object2 - Game object or matter body passed by collider / overlap. Ignored if matter CollisionInfo object was passed as first argument.\r\n *\r\n * @return {boolean} Return true if game object is overlapping ray's field of view.\r\n */\r\nexport function processOverlap(object1, object2) {\r\n    let obj1, obj2, target;\r\n    //check if it's matter collisionInfo object\r\n    if(object1.bodyA !== undefined && object1.bodyB !== undefined) {\r\n        obj1 = object1.bodyA;\r\n        obj2 = object1.bodyB;\r\n    }\r\n    else {\r\n        obj1 = object1;\r\n        obj2 = object2;\r\n    }\r\n\r\n    if(obj1._ray !== undefined && obj1._ray === this)\r\n        target = obj2;\r\n    else if(obj2._ray !== undefined && obj2._ray === this)\r\n        target = obj1;\r\n    else\r\n        return false;\r\n\r\n    return (this.overlap(target).length > 0);\r\n}   \r\n\r\n/**\r\n * Test if hitbox overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testArcadeOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.8.0\r\n *\r\n * @param {object} hitbox - Game object's hitbox generated inside {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @return {boolean} True if hitbox overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testArcadeOverlap(hitbox) {\r\n    let overlap = false;\r\n\r\n    //iterate through field of view slices to check collisions with target\r\n    for(let slice of this.slicedIntersections) {\r\n        //if hitbox is a circle\r\n        if(hitbox.type == 0) {\r\n            overlap = Phaser.Geom.Intersects.TriangleToCircle(slice, hitbox);\r\n        }\r\n        //if hitbox is a rectangle\r\n        else {\r\n            overlap = Phaser.Geom.Intersects.RectangleToTriangle(hitbox, slice);\r\n        }\r\n\r\n        if(overlap) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n/**\r\n * Test if matter body overlaps with field of view. Method used in {@link Raycaster.Ray#overlap Ray.overlap}.\r\n *\r\n * @method Raycaster.Ray#testMatterOverlap\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @private\r\n * @since 0.9.0\r\n *\r\n * @param {object} body - Matter body.\r\n *\r\n * @return {boolean} True if body overlaps with {@link Raycaster.Ray Raycaster.Ray} field of view.\r\n */\r\nexport function testMatterOverlap(object) {\r\n    let body;\r\n\r\n    if(object.type === 'body')\r\n        body = object;\r\n    else if(object.body !== undefined)\r\n        body = object.body;\r\n    else\r\n        return false;\r\n\r\n    //if body is concave, ignore convex body\r\n    let parts = body.parts.length > 1 ? body.parts.splice(1) : body.parts;\r\n    //iterate through bodies\r\n    for(let part of parts) {\r\n        let pointA = part.vertices[0];\r\n\r\n        for(let i = 1, length = part.vertices.length; i < length; i++) {\r\n            let pointB = part.vertices[i];\r\n            let segment = new Phaser.Geom.Line(pointA.x, pointA.y, pointB.x, pointB.y);\r\n\r\n            //iterate through field of view slices to check collisions with target\r\n            for(let slice of this.slicedIntersections) {\r\n                let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\r\n                //additional checking if slice contain segment's points due to TriangleToLine bug.\r\n                if(!overlap)\r\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointA());\r\n                if(!overlap)\r\n                    overlap = Phaser.Geom.Triangle.ContainsPoint(slice, segment.getPointB());\r\n\r\n                if(overlap) {\r\n                    return true;\r\n                }\r\n            }\r\n            pointA = pointB;\r\n        }\r\n\r\n        //closing segment\r\n        let segment = new Phaser.Geom.Line(part.vertices[part.vertices.length - 1].x, part.vertices[part.vertices.length - 1].y, part.vertices[0].x, part.vertices[0].y);\r\n         //iterate through field of view slices to check collisions with target\r\n        for(let slice of this.slicedIntersections) {\r\n            let overlap = Phaser.Geom.Intersects.TriangleToLine(slice, segment);\r\n\r\n            if(overlap) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n","/**\r\n * Set ray's range.\r\n *\r\n * @method Raycaster.Ray#setRayRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [rayRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRayRange(rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.rayRange = rayRange;\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's maximum detection range. Objects outside detection range won't be tested.\r\n * Ray tests all objects when set to 0.\r\n *\r\n * @method Raycaster.Ray#setDetectionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} [detectionRange = 0] - Maximum distance between ray's position and tested objects bounding boxes.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setDetectionRange(detectionRange = 0) {\r\n    this.detectionRange = detectionRange;\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y,this.detectionRange);\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * Set ray's field of view maximum collision range. Objects outside collision range won't be tested by {@link Raycaster.Ray#overlap Raycaster.Ray.overlap} method.\r\n * Determines ray's physics body radius.\r\n *\r\n * @method Raycaster.Ray#setCollisionRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {number} [collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's collision range and physics body radius.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setCollisionRange(collisionRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    let oldRangeMax = this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER;\r\n    this.collisionRange = collisionRange;\r\n    this.collisionCircle.setRadius(this.collisionRange);\r\n\r\n    if(this.bodyType === 'matter') {\r\n        if(this.collisionRange == Phaser.Math.MAX_SAFE_INTEGER) {\r\n            let bounds = this._raycaster.boundingBox;\r\n\r\n            this._raycaster.scene.matter.body.set(this.body, {\r\n                shape: {\r\n                    type: 'rectangle',\r\n                    x: bounds.rectangle.centerX,\r\n                    y: bounds.rectangle.centerY,\r\n                    width: bounds.rectangle.width,\r\n                    height: bounds.rectangle.height,\r\n                    circleRadius:0\r\n                }\r\n            });\r\n        }\r\n        else if(oldRangeMax) {\r\n            this._raycaster.scene.matter.body.set(this.body, {\r\n                shape: {\r\n                    type: 'circle',\r\n                    x: this.collisionCircle.x,\r\n                    y: this.collisionCircle.y\r\n                },\r\n                circleRadius: this.collisionRange,\r\n                isStatic: false\r\n            });\r\n        }\r\n        else {\r\n            this.collisionCircle.setRadius(this.collisionRange);\r\n        }\r\n        this._raycaster.scene.matter.body.set(this.body, 'circleRadius', this.collisionRange)\r\n    }\r\n    else if(this.bodyType === 'arcade') {\r\n        this.body.setCircle(this.collisionRange);\r\n    }\r\n\r\n    return this;\r\n}\r\n\r\n/**\r\n * Test if object's bounding box is in ray's detection range.\r\n *\r\n * @method Raycaster.Ray#boundsInRange\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {object} object - Tested object\r\n * @param {(Phaser.Geom.Rectangle|boolean)} [bounds = false] - Tested object's bounds. If not passed bounds will be generated automatically.\r\n *\r\n * @return {boolean} Information if object is in ray's detection range.\r\n */\r\nexport function boundsInRange(object, bounds = false) {\r\n    if(!this.detectionRange)\r\n        return true;\r\n\r\n    let objectBounds;\r\n    if(bounds)\r\n        objectBounds = bounds;\r\n    else {\r\n        if(object.type === 'body' || object.type === 'composite')\r\n            objectBounds = object.raycasterMap.getBoundingBox();\r\n        else\r\n            objectBounds = object.data.get('raycasterMap').getBoundingBox();\r\n    }\r\n\r\n    if(Phaser.Geom.Intersects.CircleToRectangle(this.detectionRangeCircle, objectBounds))\r\n        return true;\r\n\r\n    return false;\r\n}\r\n","/**\r\n * @classdesc\r\n *\r\n * Ray class responsible for casting ray's and testing their collisions with mapped objects.\r\n *\r\n * @namespace Raycaster.Ray\r\n * @class Raycaster.Ray\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} [options] - Ray's congfiguration options. May include:\r\n * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n * @param {Raycaster} [raycaster] - Parent raycaster object.\r\n */\r\nexport function Ray(options, raycaster) {\r\n    /**\r\n    * Reference to parent Raycaster object.\r\n    *\r\n    * @name Raycaster.Ray#_raycaster\r\n    * @type {Raycaster}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._raycaster = raycaster ? raycaster : false;\r\n    /**\r\n    * Ray's source position.\r\n    *\r\n    * @name Raycaster.Ray#origin\r\n    * @type {Phaser.Geom.Point}\r\n    * @since 0.6.0\r\n    */\r\n    this.origin = new Phaser.Geom.Point();\r\n    /**\r\n    * Ray's representation used to calculating intersections.\r\n    *\r\n    * @name Raycaster.Ray#_ray\r\n    * @type {Phaser.Geom.Line}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this._ray = new Phaser.Geom.Line();\r\n    /**\r\n    * Ray's angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#angle\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.angle = 0;\r\n    /**\r\n    * Ray's cone width angle in radians.\r\n    *\r\n    * @name Raycaster.Ray#cone\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.7.0\r\n    */\r\n    this.cone = 0;\r\n    /**\r\n    * Ray's maximum range\r\n    *\r\n    * @name Raycaster.Ray#rayRange\r\n    * @type {number}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.6.0\r\n    */\r\n    this.rayRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * Ray's maximum detection range. Objects outside detection range won't be tested.\r\n    * Ray tests all objects when set to 0.\r\n    *\r\n    * @name Raycaster.Ray#detectionRange\r\n    * @type {number}\r\n    * @default\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRange = 0;\r\n    /**\r\n    * Ray's representation of detection range used in calculating if objects are in range.\r\n    *\r\n    * @name Raycaster.Ray#detectionRangeCircle\r\n    * @type {Phaser.Geom.Circle}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.detectionRangeCircle = new Phaser.Geom.Circle();\r\n    /**\r\n    * Ray's maximum collision range of ray's field of view. Radius of {@link Raycaster.Ray#collisionRangeCircle Ray.body}.\r\n    *\r\n    * @name Raycaster.Ray#collisionRange\r\n    * @type {number}\r\n    * @default Phaser.Math.MAX_SAFE_INTEGER\r\n    * @since 0.8.0\r\n    */\r\n    this.collisionRange = Phaser.Math.MAX_SAFE_INTEGER;\r\n    /**\r\n    * If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    *\r\n    * @name Raycaster.Ray#ignoreNotIntersectedRays\r\n    * @type {boolean}\r\n    * @default true\r\n    * @since 0.6.0\r\n    */\r\n    this.ignoreNotIntersectedRays = true;\r\n    /**\r\n    * If set true, ray's hit points will be rounded.\r\n    *\r\n    * @name Raycaster.Ray#round\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.1\r\n    */\r\n    this.round = false;\r\n    /**\r\n    * If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    *\r\n    * @name Raycaster.Ray#autoSlice\r\n    * @type {boolean}\r\n    * @default false\r\n    * @since 0.8.0\r\n    */\r\n    this.autoSlice = false;\r\n    /**\r\n    * Array of intersections from last raycast representing field of view.\r\n    *\r\n    * @name Raycaster.Ray#intersections\r\n    * @type {object[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.intersections = [];\r\n    /**\r\n    * Array of triangles representing slices of field of view from last raycast.\r\n    *\r\n    * @name Raycaster.Ray#slicedIntersections\r\n    * @type {Phaser.Geom.Triangle[]}\r\n    * @default []\r\n    * @since 0.8.0\r\n    */\r\n    this.slicedIntersections = [];\r\n\r\n    /**\r\n    * Physics body for testing field of view collisions.\r\n    *\r\n    * @name Raycaster.Ray#body\r\n    * @type {object}\r\n    * @default undefined\r\n    * @since 0.8.0\r\n    */\r\n    //this.body = false;\r\n    /**\r\n    * Physics body type.\r\n    *\r\n    * @name Raycaster.Ray#bodyType\r\n    * @type {(boolean|'arcade'|'matter')}\r\n    * @default false\r\n    * @since 0.9.0\r\n    */\r\n    this.bodyType = false;\r\n\r\n    /**\r\n    * Ray casting stats.\r\n    *\r\n    * @name Raycaster.Ray#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {string} method Used casting method (cast, castCircle, castCone).\r\n    * @property {number} rays Casted rays.\r\n    * @property {number} testedMappedObjects Tested mapped objects.\r\n    * @property {number} hitMappedObjects Hit mapped objects.\r\n    * @property {number} segments Tested segments.\r\n    * @property {number} time Casting time.\r\n    */\r\n    this._stats = {\r\n        method: 'cast',\r\n        rays: 0,\r\n        testedMappedObjects: 0,\r\n        hitMappedObjects: 0,\r\n        segments: 0,\r\n        time: 0\r\n    };\r\n\r\n    /**\r\n    * Ray's graphics object used for debug\r\n    *\r\n    * @name Raycaster.Ray#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n     this.graphics;\r\n\r\n    this.config(options);\r\n};\r\n\r\nRay.prototype = {\r\n    config: require('./config.js').config,\r\n    getStats: require('./stats.js').getStats,\r\n    setRay: require('./ray.js').setRay,    \r\n    setOrigin: require('./origin.js').setOrigin,\r\n    setRayRange: require('./range.js').setRayRange,\r\n    setAngle: require('./angle.js').setAngle,\r\n    setAngleDeg: require('./angle.js').setAngleDeg,\r\n    setCone: require('./cone.js').setCone,\r\n    setConeDeg: require('./cone.js').setConeDeg,\r\n    setDetectionRange: require('./range.js').setDetectionRange,\r\n    boundsInRange: require('./range.js').boundsInRange,\r\n    cast: require('./cast.js').cast,\r\n    castCircle: require('./castCircle.js').castCircle,\r\n    castCone: require('./castCone.js').castCone,\r\n    slice: require('./slice.js').slice,\r\n    setCollisionRange: require('./range.js').setCollisionRange,\r\n    enablePhysics: require('./enablePhysics.js').enablePhysics,\r\n    overlap: require('./overlap.js').overlap,\r\n    processOverlap: require('./overlap.js').processOverlap,\r\n    testArcadeOverlap: require('./overlap.js').testArcadeOverlap,\r\n    testMatterOverlap: require('./overlap.js').testMatterOverlap,\r\n    setCollisionCategory: require('./matter-physics-methods.js').setCollisionCategory,\r\n    setCollisionGroup: require('./matter-physics-methods.js').setCollisionGroup,\r\n    setCollidesWith: require('./matter-physics-methods.js').setCollidesWith,\r\n    setOnCollide: require('./matter-physics-methods.js').setOnCollide,\r\n    setOnCollideEnd: require('./matter-physics-methods.js').setOnCollideEnd,\r\n    setOnCollideActive: require('./matter-physics-methods.js').setOnCollideActive,\r\n    setOnCollideWith: require('./matter-physics-methods.js').setOnCollideWith,\r\n    drawDebug: require('./debug.js').drawDebug,\r\n    destroy: require('./destroy.js').destroy,\r\n};\r\n","/**\r\n * Set ray's position, direction (angle) and range.\r\n *\r\n * @method Raycaster.Ray#setRay\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.6.0\r\n *\r\n * @param {number} x - X coordinate.\r\n * @param {number} y - Y coordinate.\r\n * @param {number} [angle] - Ray's angle in radians.\r\n * @param {number} [range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n *\r\n * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n */\r\nexport function setRay(x, y, angle, rayRange = Phaser.Math.MAX_SAFE_INTEGER) {\r\n    this.origin.setTo(x, y);\r\n    this.angle = Phaser.Math.Angle.Normalize(angle);\r\n    this.rayRange = rayRange;\r\n\r\n    Phaser.Geom.Line.SetToAngle(this._ray, this.origin.x, this.origin.y, this.angle, this.rayRange);\r\n    this.detectionRangeCircle.setTo(this.origin.x, this.origin.y, this.detectionRange);\r\n    return this;\r\n}\r\n","/**\r\n * Slice ray's field of view represented by polygon or array of points into array of triangles.\r\n *\r\n * @method Raycaster.Ray#slice\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.8.0\r\n *\r\n * @param {(object[]|Phaser.Geom.Polygon)} [fov = {Ray#fov}] - Array of points or polygon representing field of view. If not passed, filed of view from last raycaste will be used.\r\n * @param {boolean} [closed = true|{Ray#fov}] - Define if field of view polygon is closed (first and last vertices sholud be connected). If fov was not passed, value depends of last type of casting.\r\n *\r\n * @return {Phaser.Geom.Triangle[]} Array of triangles representing slices of field of view.\r\n */\r\nexport function slice(intersections = this.intersections, closed = true) {\r\n    //if intersections is Phaser.Geom.Polygon object\r\n    if(!Array.isArray(intersections)) {\r\n        if(intersections.type === 4)\r\n            intersections = intersections.points;\r\n        else\r\n            return [];\r\n    }\r\n\r\n    if(intersections.length === 0)\r\n        return [];\r\n\r\n    let slices = [];\r\n    for(let i = 0, iLength = intersections.length - 1; i < iLength; i++) {\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[i].x, intersections[i].y, intersections[i+1].x, intersections[i+1].y));\r\n    }\r\n\r\n    if(closed)\r\n        slices.push(new Phaser.Geom.Triangle(this.origin.x, this.origin.y, intersections[0].x, intersections[0].y, intersections[intersections.length-1].x, intersections[intersections.length-1].y));\r\n\r\n    return slices;\r\n}\r\n","/**\r\n * Get ray statistics for last casting. Stats include\r\n * * number of casted rays,\r\n * * number of tested mapped objects,\r\n * * number of tested map segments.\r\n * * casting time\r\n *\r\n * @method Raycaster.Ray#getStats\r\n * @memberof Raycaster.Ray\r\n * @instance\r\n * @since 0.10.0\r\n *\r\n * @return {object} Statisticss from last casting.\r\n */\r\n export function getStats() {\r\n     return this._stats;\r\n }\r\n","/**\r\n* @author       Marcin Walczak <contact@marcin-walczak.pl>\r\n* @copyright    2022 Marcin Walczak\r\n* @license      {@link https://github.com/wiserim/phaser-raycaster/blob/master/LICENSE|MIT License}\r\n*/\r\n\r\n/**\r\n * @classdesc\r\n *\r\n * Raycaster class responsible for creating ray objects and managing mapped objects.\r\n * \r\n * @namespace Raycaster\r\n * @class Raycaster\r\n * @constructor\r\n * @since 6.0.0\r\n *\r\n * @param {object} [options] - Raycaster's configuration options. May include:\r\n * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps. If set to 0, map will be teste\r\n * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box. If not passed, {@link Raycaster Raycaster} will set it's bounding box based on Arcade Physics / Matter physics world bounds.\r\n * @param {boolean} [options.autoUpdate = true] - If set true, automatically update dynamic maps on scene update event.\r\n * @param {boolean|object} [options.debug] - Enable debug mode or configure it {@link Raycaster#debugOptions debugOptions}.\r\n */\r\nexport function Raycaster(options) {\r\n    /**\r\n    * Plugin version.\r\n    *\r\n    * @name Raycaster#version\r\n    * @type {string}\r\n    * @readonly\r\n    * @since 0.6.0\r\n    */\r\n    this.version = '0.10.5';\r\n    /**\r\n    * Raycaster's scene\r\n    *\r\n    * @name Raycaster#scene\r\n    * @type {Phaser.Scene}\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.scene;\r\n    /**\r\n    * Raycaster's graphics object used for debug\r\n    *\r\n    * @name Raycaster#graphics\r\n    * @type {Phaser.GameObjects.Graphics}\r\n    * @private\r\n    * @since 0.10.0\r\n    */\r\n    this.graphics;\r\n    /**\r\n    * Raycaster's debug config\r\n    *\r\n    * @name Raycaster#debugOptions\r\n    * @type {Object}\r\n    * @since 0.10.0\r\n    * \r\n    * @property {boolean} [enable = false] Enable debug mode\r\n    * @property {boolean} [maps = true] - Enable maps debug\r\n    * @param {boolean} [rays = true] - Enable rays debug\r\n    * @property {boolean} graphics - Debug graphics options\r\n    * @property {boolean|number} [graphics.ray = 0x00ff00] - Debug ray color. Set false to disable.\r\n    * @property {boolean|number} [graphics.rayPoint = 0xff00ff] - Debug ray point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapPoint = 0x00ffff] - debug map point color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapSegment = 0x0000ff] - Debug map segment color. Set false to disable.\r\n    * @property {boolean|number} [graphics.mapBoundingBox = 0xff0000] - Debug map bounding box color. Set false to disable.\r\n    */\r\n    this.debugOptions = {\r\n        enabled: false,\r\n        maps: true,\r\n        rays: true,\r\n        graphics: {\r\n            ray: 0x00ff00,\r\n            rayPoint: 0xff00ff,\r\n            mapPoint: 0x00ffff,\r\n            mapSegment: 0x0000ff,\r\n            mapBoundingBox: 0xff0000\r\n        }\r\n    };\r\n\r\n    /**\r\n    * Raycaster statistics.\r\n    *\r\n    * @name Raycaster.Raycaster#_stats\r\n    * @type {object}\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @property {object} mappedObjects Mapped objects statistics.\r\n    * @property {number} mappedObjects.total Mapped objects total.\r\n    * @property {number} mappedObjects.static Static maps.\r\n    * @property {number} mappedObjects.dynamic Dynamic maps.\r\n    * @property {number} mappedObjects.rectangleMaps Rectangle maps.\r\n    * @property {number} mappedObjects.polygonMaps Polygon maps.\r\n    * @property {number} mappedObjects.circleMaps Circle maps.\r\n    * @property {number} mappedObjects.lineMaps Line maps.\r\n    * @property {number} mappedObjects.containerMaps Container maps.\r\n    * @property {number} mappedObjects.tilemapMaps Tilemap maps.\r\n    * @property {number} mappedObjects.matterMaps Matter body maps.\r\n    */\r\n     this._stats = {\r\n        mappedObjects: {\r\n            total: 0,\r\n            static: 0,\r\n            dynamic: 0,\r\n            rectangleMaps: 0,\r\n            polygonMaps: 0,\r\n            circleMaps: 0,\r\n            lineMaps: 0,\r\n            containerMaps: 0,\r\n            tilemapMaps: 0,\r\n            matterMaps: 0\r\n        }\r\n     };\r\n\r\n    /**\r\n    * Raycaster's bounding box. By default it's size is based on Arcade Physics / Matter physics world bounds.\r\n    * If world size will change after creation of Raycaster, bounding box needs to be updated.\r\n    *\r\n    * @name Raycaster#boundingBox\r\n    * @type {Phaser.Geom.Rectangle}\r\n    * @default false\r\n    * @private\r\n    * @since 0.6.0\r\n    */\r\n    this.boundingBox = false;\r\n    /**\r\n    * Array of mapped game objects.\r\n    *\r\n    * @name Raycaster#mappedObjects\r\n    * @type {object[]}\r\n    * @since 0.6.0\r\n    */\r\n    this.mappedObjects = [];\r\n    this.sortedPoints = [];\r\n    /**\r\n    * Number of segments of circle maps.\r\n    *\r\n    * @name Raycaster#mapSegmentCount\r\n    * @type {number}\r\n    * @default 0\r\n    * @since 0.6.0\r\n    */\r\n    this.mapSegmentCount = 0;\r\n\r\n    if(options !== undefined) {\r\n        if(options.boundingBox === undefined && options.scene !== undefined) {\r\n            if(options.scene.physics !== undefined)\r\n                options.boundingBox = options.scene.physics.world.bounds;\r\n            else if(options.scene.matter !== undefined) {\r\n                let walls = options.scene.matter.world.walls;\r\n\r\n                if(walls.top !== null) {\r\n                    options.boundingBox = new Phaser.Geom.Rectangle(\r\n                        walls.top.vertices[3].x,\r\n                        walls.top.vertices[3].y,\r\n                        walls.bottom.vertices[1].x - walls.top.vertices[3].x,\r\n                        walls.bottom.vertices[1].y - walls.top.vertices[3].y\r\n                    );\r\n                }\r\n            }\r\n        }\r\n\r\n        this.setOptions(options);\r\n\r\n        if(options.autoUpdate === undefined || options.autoUpdate)\r\n            //automatically update event\r\n            this.scene.events.on('update', this.update.bind(this));\r\n    }\r\n    else\r\n        //automatically update event\r\n        this.scene.events.on('update', this.update.bind(this));\r\n\r\n    return this;\r\n}\r\n\r\nRaycaster.prototype = {\r\n    /**\r\n    * Configure raycaster.\r\n    *\r\n    * @method Raycaster#setOptions\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Raycaster's congfiguration options. May include:\r\n    * @param {Phaser.Scene} [options.scene] - Scene in which Raycaster will be used.\r\n    * @param {number} [options.mapSegmentCount = 0] - Number of segments of circle maps.\r\n    * @param {(object|object[])} [options.objects] - Game object or array of game objects to map.\r\n    * @param {Phaser.Geom.Rectangle} [options.boundingBox] - Raycaster's bounding box.\r\n    * @param {boolean|object} [options.debug] - Enable debug mode or cofigure {@link Raycaster#debugOptions debugOptions}.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setOptions: function(options) {\r\n        if(options.scene !== undefined) {\r\n            this.scene = options.scene;\r\n            this.graphics =  this.scene.add.graphics({ lineStyle: { width: 1, color: 0x00ff00}, fillStyle: { color: 0xff00ff } });\r\n            this.graphics.setDepth(999);\r\n        }\r\n\r\n        if(options.debug !== undefined && options.debug !== false) {\r\n            this.debugOptions.enabled = true;\r\n\r\n            if(typeof options.debug === 'object')\r\n                Object.assign(this.debugOptions, options.debug);\r\n        }\r\n\r\n        if(options.mapSegmentCount !== undefined)\r\n            this.mapSegmentCount = options.mapSegmentCount;\r\n\r\n        if(options.objects !== undefined)\r\n            this.mapGameObjects(options.objects);\r\n\r\n        if(options.boundingBox !== undefined)\r\n            this.setBoundingBox(options.boundingBox.x, options.boundingBox.y, options.boundingBox.width, options.boundingBox.height)\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Set Raycaster's bounding box.\r\n    *\r\n    * @method Raycaster#setBoundingBox\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {number} x - The X coordinate of the top left corner of bounding box.\r\n    * @param {number} y - The Y coordinate of the top left corner of bounding box.\r\n    * @param {number} width - The width of bounding box.\r\n    * @param {number} height - The height of bounding box.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    setBoundingBox: function(x, y, width, height) {\r\n        this.boundingBox = {\r\n            rectangle: new Phaser.Geom.Rectangle(x, y, width, height),\r\n            points: [],\r\n            segments: []\r\n        }\r\n        //set points\r\n        let points = [\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.top),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.right, this.boundingBox.rectangle.bottom),\r\n            new Phaser.Geom.Point(this.boundingBox.rectangle.left, this.boundingBox.rectangle.bottom)\r\n        ];\r\n\r\n        this.boundingBox.points = points;\r\n\r\n        //set segments\r\n        for(let i = 0, length = this.boundingBox.points.length; i < length; i++) {\r\n            if(i+1 < length)\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[i+1].x, points[i+1].y));\r\n            else\r\n            this.boundingBox.segments.push(new Phaser.Geom.Line(points[i].x, points[i].y, points[0].x, points[0].y));\r\n        }\r\n    },\r\n\r\n    /**\r\n    * Map game objects\r\n    *\r\n    * @method Raycaster#mapGameObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object|object[]} objects - Game object / matter body or array of game objects / matter bodies to map.\r\n    * @param {boolean} [dynamic = false] - {@link Raycaster.Map Raycaster.Map} dynamic flag (determines map will be updated automatically).\r\n    * @param {object} [options] - Additional options for {@link Raycaster.Map Raycaster.Map}\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    mapGameObjects: function(objects, dynamic = false, options = {}) {\r\n        options.dynamic = dynamic;\r\n        options.segmentCount = (options.segmentCount !== undefined) ? options.segmentCount : this.segmentCount;\r\n\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            if(this.mappedObjects.includes(object))\r\n                continue;\r\n\r\n            //if object is not supported\r\n            if(object.data && object.data.get('raycasterMapNotSupported'))\r\n                continue;\r\n\r\n            let config = {};\r\n            for(let option in options) {\r\n                config[option] = options[option];\r\n            }\r\n            config.object = object;\r\n            \r\n            let map = new this.Map(config, this);\r\n            \r\n            if(map.notSupported) {\r\n                map.destroy();\r\n                continue;\r\n            }\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                object.raycasterMap = map;\r\n            }\r\n            else if(!object.data) {\r\n                object.setDataEnabled();\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n            else {\r\n                object.data.set('raycasterMap', map);\r\n            }\r\n\r\n            this.mappedObjects.push(object);\r\n\r\n            //update stats\r\n            if(object.dynamic)\r\n                this._stats.mappedObjects.dynamic++;\r\n            else\r\n                this._stats.mappedObjects.static++;\r\n            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps++;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps++;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps++;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps++;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps++;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps++;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps++;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Remove game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#removeMappedObjects\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be removed.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    removeMappedObjects: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n\r\n        for(let object of objects) {\r\n            let index = this.mappedObjects.indexOf(object);\r\n            if(index >= 0)\r\n                this.mappedObjects.splice(index, 1);\r\n            \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                object.raycasterMap.destroy();\r\n            else\r\n                object.data.get('raycasterMap').destroy();\r\n            \r\n            //update stats\r\n            if(object.dynamic)\r\n                this._stats.mappedObjects.dynamic--;\r\n            else\r\n                this._stats.mappedObjects.static--;\r\n            \r\n            switch(object.type) {\r\n                case 'Polygon':\r\n                    this._stats.mappedObjects.polygonMaps--;\r\n                    break;\r\n                case 'Arc':\r\n                    this._stats.mappedObjects.circleMaps--;\r\n                    break;\r\n                case 'Line':\r\n                    this._stats.mappedObjects.lineMaps--;\r\n                    break;\r\n                case 'Container':\r\n                    this._stats.mappedObjects.containerMaps--;\r\n                    break;\r\n                case 'StaticTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'DynamicTilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'TilemapLayer':\r\n                    this._stats.mappedObjects.tilemapMaps--;\r\n                    break;\r\n                case 'MatterBody':\r\n                    this._stats.mappedObjects.matterMaps--;\r\n                    break;\r\n                default:\r\n                    this._stats.mappedObjects.rectangleMaps--;\r\n            }\r\n        }\r\n\r\n        this._stats.mappedObjects.total = this.mappedObjects.length;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Enable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#enableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be enabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    enableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Disable game object's {@link Raycaster.Map Raycaster.Map} maps.\r\n    *\r\n    * @method Raycaster#disableMaps\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.7.2\r\n    *\r\n    * @param {(object|object[])} objects - Game object or array of game objects which maps will be disabled.\r\n    *\r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    disableMaps: function(objects) {\r\n        if(!Array.isArray(objects))\r\n            objects = [objects];\r\n        \r\n        for(let object of objects) {\r\n            let map;\r\n\r\n            if(object.type === 'body' || object.type === 'composite') {\r\n                map = object.raycasterMap;\r\n            }\r\n            else if(object.data) {\r\n                map = object.data.get('raycasterMap');\r\n            }\r\n\r\n            if(map)\r\n                map.active = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Updates all {@link Raycaster.Map Raycaster.Map} dynamic maps. Fired on Phaser.Scene update event.\r\n    *\r\n    * @method Raycaster#update\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n    update: function() {\r\n        //update dynamic maps\r\n        let dynamicMaps = 0;\r\n        if(this.mappedObjects.length > 0) {\r\n            for(let mapppedObject of this.mappedObjects) {\r\n                let map;\r\n\r\n                if(mapppedObject.type === 'body' || mapppedObject.type === 'composite') {\r\n                    map = mapppedObject.raycasterMap;\r\n                }\r\n                else if(mapppedObject.data) {\r\n                    map = mapppedObject.data.get('raycasterMap');\r\n                }\r\n\r\n                if(!map)\r\n                    continue;\r\n\r\n                if(map.dynamic) {\r\n                    map.updateMap();\r\n                    dynamicMaps++;\r\n                }\r\n            }\r\n\r\n            //update stats\r\n            this._stats.mappedObjects.static = this.mappedObjects.length - dynamicMaps;\r\n            this._stats.mappedObjects.dynamic = dynamicMaps;\r\n\r\n            //debug\r\n            if(this.debugOptions.enabled)\r\n                this.drawDebug();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n    * Create {@link Raycaster.Ray Raycaster.Ray} object.\r\n    *\r\n    * @method Raycaster#createRay\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.6.0\r\n    *\r\n    * @param {object} [options] - Ray's congfiguration options. May include:\r\n    * @param {Phaser.Geom.Point|Point} [options.origin = {x:0, y:0}] - Ray's position.\r\n    * @param {number} [options.angle = 0] - Ray's angle in radians.\r\n    * @param {number} [options.angleDeg = 0] - Ray's angle in degrees.\r\n    * @param {number} [options.cone = 0] - Ray's cone angle in radians.\r\n    * @param {number} [options.coneDeg = 0] - Ray's cone angle in degrees.\r\n    * @param {number} [options.range = Phaser.Math.MAX_SAFE_INTEGER] - Ray's range.\r\n    * @param {number} [options.collisionRange = Phaser.Math.MAX_SAFE_INTEGER] - Ray's maximum collision range of ray's field of view.\r\n    * @param {number} [options.detectionRange = Phaser.Math.MAX_SAFE_INTEGER] - Maximum distance between ray's position and tested objects bounding boxes.\r\n    * @param {boolean} [options.ignoreNotIntersectedRays = true] - If set true, ray returns false when it didn't hit anything. Otherwise returns ray's target position.\r\n    * @param {boolean} [options.autoSlice = false] - If set true, ray will automatically slice intersections into array of triangles and store it in {@link Raycaster.Ray#slicedIntersections Ray.slicedIntersections}.\r\n    * @param {boolean} [options.round = false] - If set true, point where ray hit will be rounded.\r\n    * @param {(boolean|'arcade'|'matter')} [options.enablePhysics = false] - Add to ray physics body. Body will be a circle with radius equal to {@link Raycaster.Ray#collisionRange Ray.collisionRange}. If set true, arcade physics body will be added.\r\n    *\r\n    * @return {Raycaster.Ray} {@link Raycaster.Ray Raycaster.Ray} instance\r\n    */\r\n    createRay: function(options = {}) {\r\n        return new this.Ray(options, this);\r\n    },\r\n\r\n    /**\r\n    * Get raycaster statistics.\r\n    *\r\n    * @method Raycaster#getStats\r\n    * @memberof Raycaster\r\n    * @instance\r\n    * @since 0.10.0\r\n    *\r\n    * @return {object} Raycaster statistics.\r\n    */\r\n    getStats: function() {\r\n        return this._stats;\r\n    },\r\n\r\n    /**\r\n    * Draw maps in debug mode\r\n    *\r\n    * @method Raycaster#drawDebug\r\n    * @memberof Raycaster\r\n    * @private\r\n    * @since 0.10.0\r\n    * \r\n    * @return {Raycaster} {@link Raycaster Raycaster} instance\r\n    */\r\n     drawDebug: function() {\r\n        if(this.graphics === undefined || !this.debugOptions.enabled)\r\n            return this;\r\n\r\n        //clear\r\n        this.graphics.clear();\r\n\r\n        if(!this.debugOptions.maps)\r\n            return this;\r\n\r\n        for(let object of this.mappedObjects)\r\n        {\r\n            let map;\r\n        \r\n            if(object.type === 'body' || object.type === 'composite')\r\n                map = object.raycasterMap;\r\n            else\r\n                map = object.data.get('raycasterMap');\r\n            \r\n            if(!map)\r\n                continue;\r\n\r\n            //draw bounding box\r\n            if(this.debugOptions.graphics.mapBoundingBox) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapBoundingBox);\r\n                this.graphics.strokeRectShape(map.getBoundingBox());\r\n            }\r\n\r\n            //draw segments\r\n            if(this.debugOptions.graphics.mapSegment) {\r\n                this.graphics.lineStyle(1, this.debugOptions.graphics.mapSegment);\r\n                for(let segment of map.getSegments()) {\r\n                    this.graphics.strokeLineShape(segment);\r\n                }\r\n            }\r\n\r\n            //draw points\r\n            if(this.debugOptions.graphics.mapPoint) {\r\n                this.graphics.fillStyle(this.debugOptions.graphics.mapPoint);\r\n                for(let point of map.getPoints()) {\r\n                    this.graphics.fillPoint(point.x, point.y, 3)\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Destroy object and all mapped objects.\r\n     *\r\n     * @method Raycaster#destroy\r\n     * @memberof Raycaster\r\n     * @instance\r\n     * @since 0.10.3\r\n     */\r\n    destroy: function() {\r\n        this.removeMappedObjects(this.mappedObjects);\r\n\r\n        for(let key in this) {\r\n            delete this[key];\r\n        }\r\n    }\r\n}\r\n\r\nRaycaster.prototype.Map = require('./map/map-core.js').Map;\r\nRaycaster.prototype.Ray = require('./ray/ray-core.js').Ray;\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(\"./src/main.js\");\n",""],"names":["PhaserRaycaster","scene","pluginManager","_Raycaster","require","Raycaster","options","Phaser","Plugins","ScenePlugin","module","exports","getBoundingBox","object","getBounds","rectangle","line","polygon","arc","container","tilemap","matterBody","segmentCount","boundingBox","config","type","undefined","getPoints","getSegments","updateMap","circle","setSegmentCount","mapChild","_circles","_updateChildMap","collisionTiles","setCollisionTiles","setOrigin","forceConvex","forceVerticesMapping","notSupported","dynamic","active","destroy","raycasterMap","data","remove","key","ray","_points","length","points","offset","Geom","Point","x","displayWidth","originX","y","displayHeight","originY","rayA","Line","rayB","c","rotation","vector","SetToAngle","Angle","Length","cB","getPointB","origin","rayLength","Math","sqrt","pow","radius","scaleX","angle","dAngle","asin","push","_segments","scaleY","geom","segments","newPoints","point","i","isChild","tempRay","_raycaster","createRay","iterate","child","bind","iLength","list","childA","mapA","get","j","jLength","childB","mapB","Intersects","RectangleToRectangle","segmentA","segmentB","intersection","LineToLine","setDataEnabled","map","constructor","set","childPoints","segment","pointA","getPointA","pointB","vectorA","vectorB","circleOffset","Circle","childMapCircle","Map","raycaster","prototype","body","circleRadius","position","scale","bodies","generateBounds","bounds","bodyItem","parts","vertices","find","segmentIndex","findIndex","x1","y1","x2","y2","splice","closingSegment","matter","composite","Rectangle","min","max","closePath","last","getTopLeft","getTopRight","getBottomRight","getBottomLeft","detectionRange","MAX_SAFE_INTEGER","Distance","Between","LineToCircle","detectionRangeCircle","horizontal","horizontals","verticals","layer","row","tile","upperEdge","includes","index","leftEdge","vertical","height","width","tileWidth","tileHeight","verticalsLastColumn","column","filter","horizontalSegment","tiles","count","setAngle","Normalize","_ray","rayRange","setAngleDeg","DegToRad","cast","closestIntersection","closestSegment","closestObject","closestDistance","internal","startTime","performance","now","stats","method","rays","testedMappedObjects","hitMappedObjects","time","intersections","GetLineToRectangle","distance","target","objects","mappedObjects","_boundingBox","setTo","Equals","isTangent","circleIntersections","GetLineToCircle","_stats","result","ignoreNotIntersectedRays","round","drawDebug","castCircle","originalAngle","maps","rayTargets","testedObjects","boundsInRange","objectB","sort","a","b","previousTarget","castSides","roundedTarget","intersectionA","intersectionB","autoSlice","slicedIntersections","slice","castCone","cone","minAngle","maxAngle","angleOffset","coneDeg","angleOffsetDeg","RadToDeg","ShortestBetween","abs","setCone","setConeDeg","angleDeg","collisionRange","enablePhysics","debugOptions","enabled","graphics","add","lineStyle","color","fillStyle","setDepth","clear","strokeLineShape","rayPoint","fillPoint","collisionCircle","bodyType","gameObject","shape","centerX","centerY","label","isSensor","ignoreGravity","setOnCollideActive","physics","existing","setCircle","setAllowGravity","setImmovable","setCollisionCategory","value","collisionFilter","category","setCollisionGroup","group","setCollidesWith","categories","flags","Array","isArray","mask","setOnCollide","callback","self","onCollideCallback","collisionInfo","rayCollided","processOverlap","setOnCollideEnd","onCollideEndCallback","func","bodyA","bodyB","onCollideWith","id","onCollideActiveCallback","setOnCollideWith","src","hasOwnProperty","overlap","targets","overlapCircle","isCollisionInfo","query","collides","getMatterBodies","testMatterOverlap","overlapCirc","hitbox","isCircle","halfWidth","testArcadeOverlap","CircleToCircle","CircleToRectangle","object1","object2","obj1","obj2","TriangleToCircle","RectangleToTriangle","part","TriangleToLine","Triangle","ContainsPoint","setRayRange","setDetectionRange","setCollisionRange","oldRangeMax","setRadius","isStatic","objectBounds","Ray","getStats","setRay","closed","slices","version","mapPoint","mapSegment","mapBoundingBox","total","static","rectangleMaps","polygonMaps","circleMaps","lineMaps","containerMaps","tilemapMaps","matterMaps","sortedPoints","mapSegmentCount","world","walls","top","bottom","setOptions","autoUpdate","events","on","update","debug","Object","assign","mapGameObjects","setBoundingBox","left","right","option","removeMappedObjects","indexOf","enableMaps","disableMaps","dynamicMaps","mapppedObject","strokeRectShape"],"sourceRoot":""}